<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Luke&#39;s blog</title>
    <link>https://ytop.net/categories/algorithm/</link>
    <description>Recent content in Algorithm on Luke&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2020 Luke. All rights reserved.</copyright>
    <lastBuildDate>Sun, 22 Mar 2020 17:30:43 +0800</lastBuildDate>
    
	<atom:link href="https://ytop.net/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode365 Water and Jug Problem</title>
      <link>https://ytop.net/post/leetcode365-water-and-jug-problem/</link>
      <pubDate>Sun, 22 Mar 2020 17:30:43 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode365-water-and-jug-problem/</guid>
      <description>365. 水壶问题 Difficulty: 中等
有两个容量分别为 x 升 和 y 升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z 升 的水？
如果可以，最后请用以上水壶中的一或两个来盛放取得的 z 升水。
你允许：
 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空  示例 1: (From the famous )
1 2  输入: x = 3, y = 5, z = 4 输出: True   示例 2:
1 2  输入: x = 2, y = 6, z = 5 输出: False   Solution Language: JavaScript
一、DFS解法 解题思路：</description>
    </item>
    
    <item>
      <title>LeetCode 115. 不同的子序列</title>
      <link>https://ytop.net/post/leetcode115-distinct-subsequences/</link>
      <pubDate>Fri, 13 Mar 2020 15:07:48 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode115-distinct-subsequences/</guid>
      <description>115. 不同的子序列 (Distinct Subsequences) Difficulty: 困难
给定一个字符串 S和一个字符串 T，计算在 S 的子序列中 T 出现的个数。
一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，&amp;quot;ACE&amp;quot; 是 &amp;quot;ABCDE&amp;quot; 的一个子序列，而 &amp;quot;AEC&amp;quot; 不是）
示例 1:
1 2 3 4 5 6 7 8 9 10 11 12 13  输入: S = &amp;#34;rabbbit&amp;#34;, T = &amp;#34;rabbit&amp;#34; 输出: 3 解释: 如下图所示, 有 3 种可以从 S 中得到 &amp;#34;rabbit&amp;#34; 的方案。 (上箭头符号 ^ 表示选取的字母) rabbbit ^^^^ ^^ rabbbit ^^ ^^^^ rabbbit ^^^ ^^^   示例 2:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  输入: S = &amp;#34;babgbag&amp;#34;, T = &amp;#34;bag&amp;#34; 输出: 5 解释: 如下图所示, 有 5 种可以从 S 中得到 &amp;#34;bag&amp;#34; 的方案。 (上箭头符号 ^ 表示选取的字母) babgbag ^^ ^ babgbag ^^ ^ babgbag ^ ^^ babgbag ^ ^^ babgbag ^^^   Solution Language: JavaScript</description>
    </item>
    
    <item>
      <title>LeetCode 44. 通配符匹配</title>
      <link>https://ytop.net/post/leetcode44/</link>
      <pubDate>Thu, 12 Mar 2020 00:21:03 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode44/</guid>
      <description>44. 通配符匹配 Difficulty: 困难
给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 &#39;?&#39; 和 &#39;*&#39; 的通配符匹配。
1 2  &amp;#39;?&amp;#39; 可以匹配任何单个字符。 &amp;#39;*&amp;#39; 可以匹配任意字符串（包括空字符串）。   两个字符串完全匹配才算匹配成功。
说明:
 s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。  示例 1:
1 2 3 4 5  输入: s = &amp;#34;aa&amp;#34; p = &amp;#34;a&amp;#34; 输出: false 解释: &amp;#34;a&amp;#34; 无法匹配 &amp;#34;aa&amp;#34; 整个字符串。   示例 2:
1 2 3 4 5  输入: s = &amp;#34;aa&amp;#34; p = &amp;#34;*&amp;#34; 输出: true 解释: &amp;#39;*&amp;#39; 可以匹配任意字符串。   示例 3:</description>
    </item>
    
    <item>
      <title>LeetCode 32. 最长有效括号</title>
      <link>https://ytop.net/post/leetcode32/</link>
      <pubDate>Mon, 09 Mar 2020 22:51:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode32/</guid>
      <description>32. 最长有效括号 Difficulty: 困难
给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。
示例 1:
1 2 3  输入: &amp;#34;(()&amp;#34; 输出: 2 解释: 最长有效括号子串为 &amp;#34;()&amp;#34;   示例 2:
1 2 3  输入: &amp;#34;)()())&amp;#34; 输出: 4 解释: 最长有效括号子串为 &amp;#34;()()&amp;#34;   Solution Language: JavaScript
解法一——暴力求解（超时） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  ​/** * @param {string} s * @return {number} */ var longestValidParentheses = function(s) { let maxLen = 0; function valid (i, j) { let stack = []; while (i &amp;lt; j) { if (s[i++] === &amp;#39;(&amp;#39;) { stack.</description>
    </item>
    
    <item>
      <title>LeetCode 76. 最小覆盖子串</title>
      <link>https://ytop.net/post/leetcode76/</link>
      <pubDate>Mon, 09 Mar 2020 09:53:57 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode76/</guid>
      <description>76. 最小覆盖子串 Difficulty: 困难
给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。
示例：
1 2  输入: S = &amp;#34;ADOBECODEBANC&amp;#34;, T = &amp;#34;ABC&amp;#34; 输出: &amp;#34;BANC&amp;#34;   说明：
 如果 S 中不存这样的子串，则返回空字符串 &amp;quot;&amp;quot;。 如果 S 中存在这样的子串，我们保证它是唯一的答案。  解题思路  要送S字符串中找出包含 T 所有字母的最小子串，那么首先就得记录T中有哪些字符，然后再去遍历 S，从S中寻找包含 T 所有字母的子串 这里我们可以先用一个map，needs来记录T中的字符，以及字符的数量 然后维护一个窗口，用索引l和r来表示这个窗口的左右边界，刚开始窗口的大小为0，即l = 0、r = 0 然后开始遍历S，从窗口的右侧依次放入元素，也用一个map， windows来记录S中的字符及其字符的数量 如果windows[c1] === needs[c1]，则说明窗口中有一个字符的数量与T中相等，则将计数器count++ 如果count等于needs中的key的数量和，则说明窗口中有T中所有的字符串，此时窗口所包含的子串就是一个包含 T 所有字母的子串 由于答案是要寻找最小的字串，所以可以记录下符合要求的子串的起始位置以及其长度，起始位置就是l，长度为r - l 找到符合要求的子串后，就开始从窗口的左侧移除字符，直到该子串不符合要求，根据将要移除的字符c，判断windows[c] === needs[c]，如果相等则要将则将计数器count--，然后移除该字符windows[c]--，最后将左边界索引l++ 重复上面的逻辑找出所有可能的子串，比较每一个子串的长度，最后返回最小的子串  Solution Language: JavaScript
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  ​/** * @param {string} s * @param {string} t * @return {string} */ var minWindow = function(s, t) { let windows = {}, needs = {}, l = 0, r = 0, count = 0, start = -1, minLen = Infinity; [.</description>
    </item>
    
    <item>
      <title>LeetCode 727. 最小窗口子序列</title>
      <link>https://ytop.net/post/leetcode727/</link>
      <pubDate>Sun, 08 Mar 2020 17:33:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode727/</guid>
      <description>727. 最小窗口子序列 Difficulty: 困难
给定字符串 S and T，找出 S 中最短的（连续）子串 W ，使得 T 是 W 的 子序列 。
如果 S 中没有窗口可以包含 T 中的所有字符，返回空字符串 &amp;quot;&amp;quot;。如果有不止一个最短长度的窗口，返回开始位置最靠左的那个。
示例 1：
1 2 3 4 5 6  输入： S = &amp;#34;abcdebdde&amp;#34;, T = &amp;#34;bde&amp;#34; 输出：&amp;#34;bcde&amp;#34; 解释： &amp;#34;bcde&amp;#34; 是答案，因为它在相同长度的字符串 &amp;#34;bdde&amp;#34; 出现之前。 &amp;#34;deb&amp;#34; 不是一个更短的答案，因为在窗口中必须按顺序出现 T 中的元素。   注：
 所有输入的字符串都只包含小写字母。All the strings in the input will only contain lowercase letters. S 长度的范围为 [1, 20000]。 T 长度的范围为 [1, 100]。  解题思路  同时遍历 S 和 T，如果 S[i] === T[j]，那么就 ++i 和 ++j，否则就只 ++i 如果 j === T.</description>
    </item>
    
    <item>
      <title>LeetCode 632. 最小区间</title>
      <link>https://ytop.net/post/leetcode632/</link>
      <pubDate>Sat, 07 Mar 2020 10:21:01 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode632/</guid>
      <description>632. 最小区间 Difficulty: 困难
你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。
我们定义如果 b-a &amp;lt; d-c 或者在 b-a == d-c 时 a &amp;lt; c，则区间 [a,b] 比 [c,d] 小。
示例 1:
1 2 3 4 5 6  输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] 输出: [20,24] 解释: 列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。 列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。 列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。   注意:
 给定的列表可能包含重复元素，所以在这里升序表示 &amp;gt;= 。 1 &amp;lt;= k &amp;lt;= 3500 -105&amp;lt;= 元素的值 &amp;lt;= 105 对于使用Java的用户，请注意传入类型已修改为List&amp;lt;List&amp;gt;。重置代码模板后可以看到这项改动。  Solution Language: JavaScript</description>
    </item>
    
    <item>
      <title>LeetCode 340. 至多包含 K 个不同字符的最长子串</title>
      <link>https://ytop.net/post/leetcode340/</link>
      <pubDate>Fri, 06 Mar 2020 02:18:30 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode340/</guid>
      <description>340. 至多包含 K 个不同字符的最长子串 Difficulty: 困难
给定一个字符串** _s_** ，找出 **至多 **包含 _k_ 个不同字符的最长子串 **_T_**。
示例 1:
1 2 3  输入: s = &amp;#34;eceba&amp;#34;, k = 2 输出: 3 解释: 则 T 为 &amp;#34;ece&amp;#34;，所以长度为 3。   示例 2:
1 2 3  输入: s = &amp;#34;aa&amp;#34;, k = 1 输出: 2 解释: 则 T 为 &amp;#34;aa&amp;#34;，所以长度为 2。   Solution 解题思路  采用双指针法，用两个指针(l, r)分别记录窗口的左右边界 用 map 来存储字符状态，以字符为 key，字符出现的次数为 value 开始遍历字符串 s，并将字符存入 map 中，如果 map 的键值个数等于 k，则说明找到了一个符合要求的子串，子串的左右边界就是 l 和 r 然后将左边界的值移出窗口，并将左边界 l++，再移动右边界 r++，直到找到下一个符合要求的子串 记录子串的长度，找出所有符合要求的最长子串，并返回该长度  代码 Language: JavaScript</description>
    </item>
    
    <item>
      <title>LeetCode 994. 腐烂的橘子</title>
      <link>https://ytop.net/post/leetcode994/</link>
      <pubDate>Thu, 05 Mar 2020 00:56:39 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode994/</guid>
      <description>994. 腐烂的橘子 Difficulty: 简单
在给定的网格中，每个单元格可以有以下三个值之一：
 值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。  每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。
返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。
示例 1：

1 2  输入：[[2,1,1],[1,1,0],[0,1,1]] 输出：4   示例 2：
1 2 3  输入：[[2,1,1],[0,1,1],[1,0,1]] 输出：-1 解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。   示例 3：
1 2 3  输入：[[0,2]] 输出：0 解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。   提示：
 1 &amp;lt;= grid.length &amp;lt;= 10 1 &amp;lt;= grid[0].</description>
    </item>
    
    <item>
      <title>LeetCode 30. 串联所有单词的子串</title>
      <link>https://ytop.net/post/leetcode30/</link>
      <pubDate>Wed, 26 Feb 2020 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode30/</guid>
      <description>给定一个字符串 &lt;strong&gt;s&lt;/strong&gt; 和一些长度相同的单词 &lt;strong&gt;words&lt;/strong&gt;找出 &lt;strong&gt;s&lt;/strong&gt; 中恰好可以由 &lt;strong&gt;words&lt;/strong&gt; 中所有单词串联形成的子串的起始位置。
注意子串要与 &lt;strong&gt;words&lt;/strong&gt; 中的单词完全匹配，中间不能有其他字符，但不需要考虑 &lt;strong&gt;words&lt;/strong&gt;中单词串联的顺序。</description>
    </item>
    
    <item>
      <title>LeetCode 695. 岛屿的最大面积</title>
      <link>https://ytop.net/post/leetcode695-max-area-of-island/</link>
      <pubDate>Tue, 18 Feb 2020 22:36:16 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode695-max-area-of-island/</guid>
      <description>695. 岛屿的最大面积(Max Area of Island) Difficulty: 中等
给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。
找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)
示例 1:
1 2 3 4 5 6 7 8  [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]   对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。
示例 2:
1  [[0,0,0,0,0,0,0,0]]   对于上面这个给定的矩阵, 返回 0。
注意: 给定的矩阵grid 的长度和宽度都不超过 50。
Solution 解题思路：
 要找出最大岛屿的面积，那肯定需要遍历所有的岛屿，这里可以选深度优先或者广度优先来进行遍历 当遍历到当前坐标为 1 时，我们同时需要对当前左边上下左右四个方向进行判断，判断其是否为是岛屿 为了防止岛屿间的重复遍历，每当遍历到当前坐标为 1 后，就将其置为 0  代码 Language: JavaScript</description>
    </item>
    
    <item>
      <title>LeetCode 208. 实现 Trie (前缀树)</title>
      <link>https://ytop.net/post/leetcode208-implement-trie/</link>
      <pubDate>Sat, 15 Feb 2020 12:51:39 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode208-implement-trie/</guid>
      <description>208. 实现 Trie (前缀树) Difficulty: 中等
实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。
示例:
1 2 3 4 5 6 7 8  Trie trie = new Trie(); trie.insert(&amp;#34;apple&amp;#34;); trie.search(&amp;#34;apple&amp;#34;); // 返回 true trie.search(&amp;#34;app&amp;#34;); // 返回 false trie.startsWith(&amp;#34;app&amp;#34;); // 返回 true trie.insert(&amp;#34;app&amp;#34;); trie.search(&amp;#34;app&amp;#34;); // 返回 true   说明:
 你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。  Trie 基本结构  字典树，即 Trie 树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串(但不仅限于 字符串)，所以经常被搜索引擎系统用于文本词频统计。 它的优点是:最大限度地减少 无谓的字符串比较，查询效率 比哈希表高。  Trie 基本性质  结点本身不存完整单词; 从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的 字符串; 每个结点的所有子结点路径代表的字符都不相同。  Trie 核心思想  Trie 树的核心思想是空间换时间。 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。  Solution Language: JavaScript</description>
    </item>
    
    <item>
      <title>N-Sum 问题</title>
      <link>https://ytop.net/post/nsum/</link>
      <pubDate>Fri, 25 May 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/nsum/</guid>
      <description>问题描述 给定一个包含多个整数且排好序的数组 nums 和一个目标值 target，判断 nums 中是否存在 N(N&amp;gt;1) 个元素，使得 N 个元素之和与 target 相等？找出所有满足条件且不重复的N元组。
解题思路 通过递归降幂将 N-Sum问题 降幂到 2-Sum 问题，然后采用两边加逼的办法求解
JavaScript 版本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  /** * @param {number[]} nums * @param {number} target * @param {number} n * @param {number[]} result * @param {number[]} results 结果集 */ function findNsum(nums, target, n, result, results) { if(n&amp;lt;2 || nums.</description>
    </item>
    
    <item>
      <title>排序算法之堆排序</title>
      <link>https://ytop.net/post/heapsort/</link>
      <pubDate>Fri, 09 Feb 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/heapsort/</guid>
      <description>排序算法总览：
堆排序 二叉树 要了解堆首先得了解一下二叉树，在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。
二叉树的每个结点至多只有二棵子树（不存在度大于 2 的结点），二叉树的子树有左右之分，次序不能颠倒。二叉树的第 i 层至多有 2i - 1 个结点；深度为 k 的二叉树至多有 2k - 1 个结点；对任何一棵二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为 n2，则n0 = n2 + 1。
树和二叉树的三个主要差别：
 树的结点个数至少为 1，而二叉树的结点个数可以为 0 树中结点的最大度数没有限制，而二叉树结点的最大度数为 2 树的结点无左、右之分，而二叉树的结点有左、右之分  二叉树又分为完全二叉树（complete binary tree）和满二叉树（full binary tree）
满二叉树：一棵深度为 k，且有 2k - 1 个节点称之为满二叉树
完全二叉树：深度为 k，有 n 个节点的二叉树，当且仅当其每一个节点都与深度为 k 的满二叉树中序号为 1 至 n 的节点对应时，称之为完全二叉树
什么是堆？ 堆（二叉堆）可以视为一棵完全的二叉树，完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。
如下图，是一个堆和数组的相互关系
对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标：
 Parent(i) = floor(i/2)，i 的父节点下标 Left(i) = 2i，i 的左子节点下标 Right(i) = 2i + 1，i 的右子节点下标  二叉堆一般分为两种：最大堆和最小堆。</description>
    </item>
    
    <item>
      <title>排序算法之归并排序</title>
      <link>https://ytop.net/post/mergesort/</link>
      <pubDate>Fri, 09 Feb 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/mergesort/</guid>
      <description>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。
归并排序可以使用递归和迭代两种方式进行实现</description>
    </item>
    
    <item>
      <title>排序算法之快速排序</title>
      <link>https://ytop.net/post/quicksort/</link>
      <pubDate>Fri, 09 Feb 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/quicksort/</guid>
      <description>快速排序是图灵奖得主 C. R. A. Hoare 于 1960 年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。
分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。
利用分治法可将快速排序的分为三步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在数据集之中，选择一个元素作为”基准”（pivot）。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>排序算法之希尔排序</title>
      <link>https://ytop.net/post/shellsort/</link>
      <pubDate>Thu, 08 Feb 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/shellsort/</guid>
      <description>希尔排序(Shell&amp;rsquo;s Sort)也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： * 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； * 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；
希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序。</description>
    </item>
    
    <item>
      <title>排序算法之直接插入排序</title>
      <link>https://ytop.net/post/straightinsertionsort/</link>
      <pubDate>Thu, 08 Feb 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/straightinsertionsort/</guid>
      <description>常见的内部排序算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、基数排序等。这里主要介绍直接插入排序. 直接插入排序(Straight Insertion Sort)的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。</description>
    </item>
    
    <item>
      <title>排序算法之选择排序</title>
      <link>https://ytop.net/post/selectionsort/</link>
      <pubDate>Thu, 08 Feb 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/selectionsort/</guid>
      <description>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。</description>
    </item>
    
    <item>
      <title>排序算法之冒泡排序</title>
      <link>https://ytop.net/post/bubblesort/</link>
      <pubDate>Thu, 08 Feb 2018 10:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/bubblesort/</guid>
      <description>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名“冒泡排序”。</description>
    </item>
    
  </channel>
</rss>