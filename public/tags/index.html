<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>GOYTH </title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.65.3" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
<link rel="shortcut icon" href="/https://img-1256541035.cos.ap-shanghai.myqcloud.com/imgs/favicon-red-bird.png" type="image/x-icon" />

    

    
    
      <link href="/tags/index.xml" rel="alternate" type="application/rss+xml" title="GOYTH" />
      <link href="/tags/index.xml" rel="feed" type="application/rss+xml" title="GOYTH" />
      
    
    
    <meta property="og:title" content="Tags" />
<meta property="og:description" content="I hear and I forget, I see and I remember, I do and I understand." />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://goyth.cn/tags/" />
<meta property="og:updated_time" content="2020-02-26T21:53:54+08:00" />
<meta itemprop="name" content="Tags">
<meta itemprop="description" content="I hear and I forget, I see and I remember, I do and I understand."><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Tags"/>
<meta name="twitter:description" content="I hear and I forget, I see and I remember, I do and I understand."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  
  
  <header class="cover bg-top" style="background-image: url('https://goyth.cn/images/gohugo-default-sample-hero-image.jpg');">
    <div class="bg-black-60">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://goyth.cn/" class="f3 fw2 hover-white no-underline white-90 dib">
      GOYTH
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="About page">
              About
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/posts/" title="Articles page">
              Articles
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/contact/" title="Contact page">
              Contact
            </a>
          </li>
          
        </ul>
      
      




<a href="https://twitter.com/goythz" target="_blank" class="link-transition twitter link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel="noopener" aria-label="follow on Twitter——Opens in a new window">
  <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>





<a href="https://github.com/jsyt" target="_blank" class="link-transition github link dib z-999 pt3 pt0-l mr1" title="Github link" rel="noopener" aria-label="follow on Github——Opens in a new window">
  <svg  height="32px"  style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
  <path d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"/>
</svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>







    </div>
  </div>
</nav>

      <div class="tc-l pv4 pv6-l ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 white-90 mb0 lh-title">
          Tags
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
    
  <article class="cf pa3 pa4-m pa4-l">
    <div class="measure-wide-l center f4 lh-copy nested-copy-line-height nested-links nested-img mid-gray">
      
    </div>
  </article>
  <div class="mw8 center">
    <section class="ph4">
      
        <h2 class="f1">
          <a href="/tags/algorithm" class="link blue hover-black">
            Tag: algorithm
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2020/02/26/leetcode30/" class="link black dim">
        LeetCode 30. 串联所有单词的子串
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      给定一个字符串 <strong>s</strong> 和一些长度相同的单词 <strong>words</strong>找出 <strong>s</strong> 中恰好可以由 <strong>words</strong> 中所有单词串联形成的子串的起始位置。
注意子串要与 <strong>words</strong> 中的单词完全匹配，中间不能有其他字符，但不需要考虑 <strong>words</strong>中单词串联的顺序。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/05/25/nsum/" class="link black dim">
        N-Sum 问题
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      问题描述 给定一个包含多个整数且排好序的数组 nums 和一个目标值 target，判断 nums 中是否存在 N(N&gt;1) 个元素，使得 N 个元素之和与 target 相等？找出所有满足条件且不重复的N元组。
解题思路 通过递归降幂将 N-Sum问题 降幂到 2-Sum 问题，然后采用两边加逼的办法求解
JavaScript 版本 /** * @param {number[]} nums * @param {number} target * @param {number} n * @param {number[]} result * @param {number[]} results 结果集 */ function findNsum(nums, target, n, result, results) { if(n&lt;2 || nums.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/02/09/heapsort/" class="link black dim">
        排序算法之堆排序
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      排序算法总览：
堆排序 二叉树 要了解堆首先得了解一下二叉树，在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。
二叉树的每个结点至多只有二棵子树（不存在度大于 2 的结点），二叉树的子树有左右之分，次序不能颠倒。二叉树的第 i 层至多有 2i - 1 个结点；深度为 k 的二叉树至多有 2k - 1 个结点；对任何一棵二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为 n2，则n0 = n2 + 1。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/02/09/mergesort/" class="link black dim">
        排序算法之归并排序
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。
归并排序可以使用递归和迭代两种方式进行实现
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/02/09/quicksort/" class="link black dim">
        排序算法之快速排序
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      快速排序是图灵奖得主 C. R. A. Hoare 于 1960 年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。
分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。
利用分治法可将快速排序的分为三步：</p>
<ol>
<li>在数据集之中，选择一个元素作为”基准”（pivot）。</li>
</ol>
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/02/08/shellsort/" class="link black dim">
        排序算法之希尔排序
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      希尔排序(Shell&rsquo;s Sort)也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： * 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； * 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；
希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/02/08/straightinsertionsort/" class="link black dim">
        排序算法之直接插入排序
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      常见的内部排序算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、基数排序等。这里主要介绍直接插入排序. 直接插入排序(Straight Insertion Sort)的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/02/08/selectionsort/" class="link black dim">
        排序算法之选择排序
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/02/08/bubblesort/" class="link black dim">
        排序算法之冒泡排序
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名“冒泡排序”。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/ast" class="link blue hover-black">
            Tag: ast
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/12/23/ast/" class="link black dim">
        抽象语法树AST介绍
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      js编译执行的第一步是读取 js 文件中的字符流，然后通过词法分析生成token，之后再通过语法分析生成 AST（Abstract Syntax Tree），最后生成机器码执行。词法分析，也称之为扫描（scanner），简单来说就是调用 next() 方法，一个一个字母的来读取字符，然后与定义好的 JavaScript 关键字符做比较，生成对应的Token。Token 是一个不可分割的最小单元，例如 var 这三个字符，它只能作为一个整体，语义上不能再被分解，因此它是一个 Token。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/babel" class="link blue hover-black">
            Tag: babel
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2019/01/06/babelplugin/" class="link black dim">
        编写一个 Babel 插件
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Babel转译流程 Babel 对源码进行转译时，主要有三个步骤  首先通过Babylon 将源码转化成 AST 然后再通过babel-traverse遍历 AST，找到需要更改的 AST 节点，对其进行修改 根据修改后的 AST，通过babel-generator将修改后的 AST重新生成源码 Babel插件主要是处理第二步。  Babylon Babylon 是 Babel 的解析器，主要负责将源码转化成 AST。
import * as babylon from &#34;babylon&#34;; const code = `function square(n) { return n * n; }`; babylon.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2019/01/05/babel/" class="link black dim">
        Babel 核心模块介绍
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Babel 介绍 Babel 是一个通用的多用途 JavaScript 编译器。通过 Babel 你可以使用（并创建）下一代的 JavaScript，以及下一代的 JavaScript 工具。 Babel 把用最新标准编写的 JavaScript 代码向下编译成可以在今天随处可用的版本。 这一过程叫做“源码到源码”编译， 也被称为转换编译（transpiling，是一个自造合成词，即转换＋编译。以下也简称为转译）。
例如，Babel 能够将新的 ES2015 箭头函数语法：
const square = n =&gt; n * n; 转译为：
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/browser" class="link blue hover-black">
            Tag: browser
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/12/02/v8gc/" class="link black dim">
        JavaScript垃圾回收机制与内存泄漏
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      程序的运行需要分配内存，内存资源是有限的，当程序运行结束后，就应该回收其内存资源。JavaScript使用自动内存管理，也称为垃圾回收机制（garbage collector）。自动垃圾回收的优点是可以简化开发，不用时刻惦记着回收不再使用的变量，降低内存泄漏的可能性；缺点是无法完全的掌握内存的分配以及回收的具体过程。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/07/01/browsecache/" class="link black dim">
        浏览器的缓存机制梳理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h2 id="概述">概述</h2>
<p>浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种：</p>
<p>HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)，如下图</p>
<p><img src="https://img-1256541035.cos.ap-shanghai.myqcloud.com/imgs/browseCache-01.webp" alt=""></p>
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/06/29/crossdomain/" class="link black dim">
        浏览器常见跨域方式梳理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <p>跨域是由于<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源策略</a>导致的，所以跨域只存在于浏览器端，非浏览器端不存在跨域问题，浏览器对跨域的请求、应答都能正常发送接收，只是浏览器在接收跨域应答时，将应答拦截了，所以我们需要一些额外的处理或设置让浏览器将跨域的应答返回给我们。</p>
<h4 id="常见的跨域处理方式有">常见的跨域处理方式有：</h4>
<ul>
<li>jsonp</li>
<li>CORS</li>
<li>iframe + postMessage</li>
<li>iframe + window.name</li>
<li>iframe + location.hash</li>
<li>iframe + domain</li>
<li>nginx代理</li>
<li>Nodejs中间件</li>
<li>WebSocket</li>
</ul>
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/05/25/reflowandrepaint/" class="link black dim">
        浏览器渲染之回流（Reflow）与重绘（Repaint）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      回流（Reflow）和重绘（Repaint）的定义 回流（Reflow） 对于DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式（浏览器的、开发人员定义的等）来计算，并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow。 重绘（Repaint） 当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为 repaint。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/05/23/browserrendering/" class="link black dim">
        浏览器页面渲染流程梳理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h2 id="浏览器渲染基本流程">浏览器渲染基本流程</h2>
<p>浏览器渲染流程如下图所示：</p>
<p><img src="https://img-1256541035.cos.ap-shanghai.myqcloud.com/imgs/browserRendering-webkitflow.png" alt=""></p>
<p>大概可以划分成以下几个步骤：</p>
<ol>
<li>通过HTML解析器解析HTML文本并构建DOM tree</li>
<li>通过CSS解析器解析CSS样式表并构建CSSOM tree</li>
<li>根据DOM tree 和 CSSOM tree 构建 Render tree</li>
</ol>
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/database" class="link blue hover-black">
            Tag: database
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/10/13/mongodb2/" class="link black dim">
        MongoDB 知识点梳理(二)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      MongoDB通过配置项启动数据库 启动服务器 mongod --config mongo.conf 启动客户端 mongo --port 50000    参数 含义     &ndash;dbpath 指定数据库文件的目录   &ndash;port 端口 默认是27017 28017   &ndash;fork 以后台守护的方式进行启动   &ndash;logpath 指定日志文件输出路径   &ndash;config 指定一个配置文件   &ndash;auth 以安全方式启动数据库，默认不验证    mongo.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/10/12/mongodb/" class="link black dim">
        MongoDB 知识点梳理（一）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      MongoDB是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。 MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/debounce" class="link blue hover-black">
            Tag: debounce
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/05/10/debounceandthrottle/" class="link black dim">
        JavaScript 之函数防抖与节流
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      函数防抖（debounce) 函数防抖是指在函数调用动作触发n秒后才开始执行，n秒内若再次触发，则重新开始计时，再次等待n秒后才开始执行。如果n秒内不断触发，那就不断重新开始计时，一直等到有一个n秒内没有触发，才开始执行此函数。
根据描述，我们可以用setTimeout来实现一个简单版的防抖函数
第一版 ／** * @ fn 回调函数 * @ delay 延迟时间 *／ function debounce(fn, delay){ let timer = null; return function(){ clearTimeout(timer); timer = setTimeout(fn, delay); } } 由于setTimeout的回调函数内的this是指向window，如果不传参数则argument对象为空，所以我们得修复this的指向，并将argument对象也传给回调函数
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/dns" class="link blue hover-black">
            Tag: dns
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/07/07/dns/" class="link black dim">
        DNS知识点梳理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      DNS 服务器 DNS( Domain Name System)是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于TCP/IP网络，它所提供的服务是用来将主机名和域名转换为IP地址的工作。DNS就是这样的一位“翻译官”，它的基本工作原理可用下图来表示。
全世界所有的人每天上网都会使用DNS服务器，如果大家都去同一个地方访问某一台服务器，时延将会非常大，所以DNS服务器的架构必须是分布式、高并发、高可用，如下图：
 根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址 顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址 权威 DNS 服务器 ：返回相应主机的 IP 地址  DNS域名解析过程 当用户在浏览器中输入www.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/express" class="link blue hover-black">
            Tag: express
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2019/07/20/expressmiddleware/" class="link black dim">
        Express路由与中间件原理（中间件篇）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <code>Express</code> 路由原理见 <a href="http://www.goyth.com/2019/07/20/expressRouter/">Express路由与中间件原理（路由篇）</a> <code>Express</code> 中间件通常用来一些公用的逻辑，并可以将处理的结果挂载在 <code>req</code>、<code>res</code> 上，以供后面的中间件函数，或路由函数使用。因此通常情况下中间件函数会放在路由的前面。在 <code>Express</code> 中，注册一个中间件与注册一个路由一样，也是放在 <code>app.routes</code> 中，只是中间件的 <code>method</code> 为 middle。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2019/07/20/expressrouter/" class="link black dim">
        Express路由与中间件原理（路由篇）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      导入 <code>express</code> 后会得到一个 <code>express</code> 函数，执行这个函数后返回一个 <code>app</code> <code>函数，app</code> 上有一个 <code>listen</code> 函数，执行这个 <code>listen</code> 函数就会启一个 <code>http</code> 服务，通过 <code>app.get</code>、<code>app.post</code>、<code>app.all</code>等函数来注册监听函数，如果 <code>http server</code> 监听到有请求到来，就会调用在 <code>app</code> 上注册的相应的回调函数。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/golang" class="link blue hover-black">
            Tag: golang
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2019/06/08/golanglearning01/" class="link black dim">
        golang 学习笔记（一）——语法篇
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      golang 应⽤程序⼊⼝  必须是 main 包：package main 必须是 main ⽅法：func main() ⽂件名不⼀定是 main.go  退出返回值 与其他主要编程语⾔的差异
 Go 中 main 函数不⽀持任何返回值 通过 os.Exit 来返回状态  获取命令⾏参数 与其他主要编程语⾔的差异
 main 函数不⽀持传⼊参数 func main(arg []string) 在程序中直接通过 os.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/http" class="link blue hover-black">
            Tag: http
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/07/11/http2/" class="link black dim">
        HTTP知识点整理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <p>HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。于2015年正式发布，HTTP/2解决了HTTP1.1线头阻塞、重复建立TCP连接等问题，充分利用TCP连接的高效传输，使得网络延迟大幅下降，网络传输速度大幅提升。</p>
<h2 id="http09---1991">HTTP/0.9 - 1991</h2>
<p>第一版的HTTP文档是1991年提出来的 HTTP/0.9。这是有史以来最简单的协议；它仅有一个GET方法。如果客户端要访问服务器上的一些网页，它会作出如下的简单请求：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">GET <span style="color:#ff79c6">/</span>index.html
</code></pre></div>
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/javascript" class="link blue hover-black">
            Tag: javascript
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2019/05/25/sparouter/" class="link black dim">
        单页面（SPA）路由实现原理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      什么是单页面应用 ? 单页面应用（SPA）即single page application，目前在前后端分离的项目中，一般都是采用 SPA 的模式，整个应用只有一个 html 页面。后端接口只负责提供数据，而页面路由则需要前端自己完成。单页面应用的优势：1. 减少 http 请求数，降低服务器压力；2. 有利于前后端分离；3. 页面流畅度更高，用户体验更加友好。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2019/01/06/babelplugin/" class="link black dim">
        编写一个 Babel 插件
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Babel转译流程 Babel 对源码进行转译时，主要有三个步骤  首先通过Babylon 将源码转化成 AST 然后再通过babel-traverse遍历 AST，找到需要更改的 AST 节点，对其进行修改 根据修改后的 AST，通过babel-generator将修改后的 AST重新生成源码 Babel插件主要是处理第二步。  Babylon Babylon 是 Babel 的解析器，主要负责将源码转化成 AST。
import * as babylon from &#34;babylon&#34;; const code = `function square(n) { return n * n; }`; babylon.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2019/01/05/babel/" class="link black dim">
        Babel 核心模块介绍
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Babel 介绍 Babel 是一个通用的多用途 JavaScript 编译器。通过 Babel 你可以使用（并创建）下一代的 JavaScript，以及下一代的 JavaScript 工具。 Babel 把用最新标准编写的 JavaScript 代码向下编译成可以在今天随处可用的版本。 这一过程叫做“源码到源码”编译， 也被称为转换编译（transpiling，是一个自造合成词，即转换＋编译。以下也简称为转译）。
例如，Babel 能够将新的 ES2015 箭头函数语法：
const square = n =&gt; n * n; 转译为：
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/12/23/ast/" class="link black dim">
        抽象语法树AST介绍
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      js编译执行的第一步是读取 js 文件中的字符流，然后通过词法分析生成token，之后再通过语法分析生成 AST（Abstract Syntax Tree），最后生成机器码执行。词法分析，也称之为扫描（scanner），简单来说就是调用 next() 方法，一个一个字母的来读取字符，然后与定义好的 JavaScript 关键字符做比较，生成对应的Token。Token 是一个不可分割的最小单元，例如 var 这三个字符，它只能作为一个整体，语义上不能再被分解，因此它是一个 Token。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/12/02/v8gc/" class="link black dim">
        JavaScript垃圾回收机制与内存泄漏
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      程序的运行需要分配内存，内存资源是有限的，当程序运行结束后，就应该回收其内存资源。JavaScript使用自动内存管理，也称为垃圾回收机制（garbage collector）。自动垃圾回收的优点是可以简化开发，不用时刻惦记着回收不再使用的变量，降低内存泄漏的可能性；缺点是无法完全的掌握内存的分配以及回收的具体过程。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/08/03/promise/" class="link black dim">
        Promise实现原理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      1.<code>promise</code> 函数的参数（executor）是一个函数，这个函数有两个参数<code>resolve</code>和<code>reject</code>，这两个参数也都是函数，分别在<code>promise</code>成功和失败时调用。 2. 当构建一个<code>promise</code>实例时，会自动调用这个函数（executor） 3. 每个<code>promise</code>对象都有一个<code>onFulfilledCallback</code>队列和一个<code>onRejectedCallback</code>队列，用来分别存储成功和失败时调用的回调函数
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/07/01/browsecache/" class="link black dim">
        浏览器的缓存机制梳理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h2 id="概述">概述</h2>
<p>浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种：</p>
<p>HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)，如下图</p>
<p><img src="https://img-1256541035.cos.ap-shanghai.myqcloud.com/imgs/browseCache-01.webp" alt=""></p>
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/06/29/crossdomain/" class="link black dim">
        浏览器常见跨域方式梳理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <p>跨域是由于<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源策略</a>导致的，所以跨域只存在于浏览器端，非浏览器端不存在跨域问题，浏览器对跨域的请求、应答都能正常发送接收，只是浏览器在接收跨域应答时，将应答拦截了，所以我们需要一些额外的处理或设置让浏览器将跨域的应答返回给我们。</p>
<h4 id="常见的跨域处理方式有">常见的跨域处理方式有：</h4>
<ul>
<li>jsonp</li>
<li>CORS</li>
<li>iframe + postMessage</li>
<li>iframe + window.name</li>
<li>iframe + location.hash</li>
<li>iframe + domain</li>
<li>nginx代理</li>
<li>Nodejs中间件</li>
<li>WebSocket</li>
</ul>
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/05/27/applyandcall/" class="link black dim">
        JavaScript之apply、call和bind的模拟实现
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      apply() apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。当第一个参数为 null 时，函数上下文为 window。
var obj = { name : &#39;luke&#39; } function func(age, gender){ console.log(this.name + &#39; &#39; + age + &#39; &#39; + gender); } func.apply(obj, [18, &#39;male&#39;]); // luke 18 male apply模拟实现 Function.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/05/25/reflowandrepaint/" class="link black dim">
        浏览器渲染之回流（Reflow）与重绘（Repaint）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      回流（Reflow）和重绘（Repaint）的定义 回流（Reflow） 对于DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式（浏览器的、开发人员定义的等）来计算，并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow。 重绘（Repaint） 当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为 repaint。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/05/23/browserrendering/" class="link black dim">
        浏览器页面渲染流程梳理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h2 id="浏览器渲染基本流程">浏览器渲染基本流程</h2>
<p>浏览器渲染流程如下图所示：</p>
<p><img src="https://img-1256541035.cos.ap-shanghai.myqcloud.com/imgs/browserRendering-webkitflow.png" alt=""></p>
<p>大概可以划分成以下几个步骤：</p>
<ol>
<li>通过HTML解析器解析HTML文本并构建DOM tree</li>
<li>通过CSS解析器解析CSS样式表并构建CSSOM tree</li>
<li>根据DOM tree 和 CSSOM tree 构建 Render tree</li>
</ol>
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/05/10/debounceandthrottle/" class="link black dim">
        JavaScript 之函数防抖与节流
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      函数防抖（debounce) 函数防抖是指在函数调用动作触发n秒后才开始执行，n秒内若再次触发，则重新开始计时，再次等待n秒后才开始执行。如果n秒内不断触发，那就不断重新开始计时，一直等到有一个n秒内没有触发，才开始执行此函数。
根据描述，我们可以用setTimeout来实现一个简单版的防抖函数
第一版 ／** * @ fn 回调函数 * @ delay 延迟时间 *／ function debounce(fn, delay){ let timer = null; return function(){ clearTimeout(timer); timer = setTimeout(fn, delay); } } 由于setTimeout的回调函数内的this是指向window，如果不传参数则argument对象为空，所以我们得修复this的指向，并将argument对象也传给回调函数
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/04/23/prototypeandextend/" class="link black dim">
        JavaScript 原型链与继承
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h3 id="原型对象">原型对象</h3>
<p>无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 <code>prototype</code> 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个 <code>constructor</code>（构造函数）属性，这个属性指向 <code>prototype</code> 属性所在的函数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#8be9fd;font-style:italic">function</span> Person(){
}
</code></pre></div>
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/04/01/jsregexp/" class="link black dim">
        JavaScript 正则表达式
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      正则表达式 一种几乎可以在所有的程序设计语言里和所有的计算机平台上使用的文字处理工具。它可以用来查找特定的信息（搜索），也可以用来查找并编辑特定的信息（替换）。 核心是 匹配，匹配位置或者匹配字符
先简单的介绍一下语法 基本元字符   .： 匹配除了换行符之外的任何单个字符
  \ ： 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前\的'b'通常匹配小写'b'，无论它们出现在哪里。如果加了'\',这个字符变成了一个特殊意义的字符，反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a*/ 代表会匹配 0 a。相反，模式 /a\*/ 将 ' * ' 的特殊性移除，从而可以匹配像 &quot;a*&quot; 这样的字符串。
  | ： 逻辑或操作符
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/leetcode" class="link blue hover-black">
            Tag: leetcode
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2020/02/26/leetcode30/" class="link black dim">
        LeetCode 30. 串联所有单词的子串
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      给定一个字符串 <strong>s</strong> 和一些长度相同的单词 <strong>words</strong>找出 <strong>s</strong> 中恰好可以由 <strong>words</strong> 中所有单词串联形成的子串的起始位置。
注意子串要与 <strong>words</strong> 中的单词完全匹配，中间不能有其他字符，但不需要考虑 <strong>words</strong>中单词串联的顺序。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/mongodb" class="link blue hover-black">
            Tag: mongodb
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/10/13/mongodb2/" class="link black dim">
        MongoDB 知识点梳理(二)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      MongoDB通过配置项启动数据库 启动服务器 mongod --config mongo.conf 启动客户端 mongo --port 50000    参数 含义     &ndash;dbpath 指定数据库文件的目录   &ndash;port 端口 默认是27017 28017   &ndash;fork 以后台守护的方式进行启动   &ndash;logpath 指定日志文件输出路径   &ndash;config 指定一个配置文件   &ndash;auth 以安全方式启动数据库，默认不验证    mongo.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/10/12/mongodb/" class="link black dim">
        MongoDB 知识点梳理（一）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      MongoDB是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。 MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/network" class="link blue hover-black">
            Tag: network
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/07/11/http2/" class="link black dim">
        HTTP知识点整理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <p>HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。于2015年正式发布，HTTP/2解决了HTTP1.1线头阻塞、重复建立TCP连接等问题，充分利用TCP连接的高效传输，使得网络延迟大幅下降，网络传输速度大幅提升。</p>
<h2 id="http09---1991">HTTP/0.9 - 1991</h2>
<p>第一版的HTTP文档是1991年提出来的 HTTP/0.9。这是有史以来最简单的协议；它仅有一个GET方法。如果客户端要访问服务器上的一些网页，它会作出如下的简单请求：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">GET <span style="color:#ff79c6">/</span>index.html
</code></pre></div>
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/07/09/websocket/" class="link black dim">
        WebSocket知识点梳理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h2 id="什么是websocket">什么是WebSocket</h2>
<p>WebSocket是一种在单个TCP连接上进行全双工通讯的协议。它与HTTP协一样，同属于应用层协议。</p>
<h2 id="websocket解决了什么问题">WebSocket解决了什么问题</h2>
<p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，<strong>允许服务端主动向客户端推送数据</strong>。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建<strong>持久性的连接</strong>，并进行<strong>双向数据传输</strong>。
简单说就是解决了浏览器和服务器之间双向数据传输的问题。</p>
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/07/07/dns/" class="link black dim">
        DNS知识点梳理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      DNS 服务器 DNS( Domain Name System)是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于TCP/IP网络，它所提供的服务是用来将主机名和域名转换为IP地址的工作。DNS就是这样的一位“翻译官”，它的基本工作原理可用下图来表示。
全世界所有的人每天上网都会使用DNS服务器，如果大家都去同一个地方访问某一台服务器，时延将会非常大，所以DNS服务器的架构必须是分布式、高并发、高可用，如下图：
 根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址 顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址 权威 DNS 服务器 ：返回相应主机的 IP 地址  DNS域名解析过程 当用户在浏览器中输入www.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/07/04/tcpip/" class="link black dim">
        TCP/IP 协议知识点梳理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h2 id="tcpip协议">TCP/IP协议</h2>
<p>TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。</p>
<h3 id="tcpip-协议分层模型">TCP/IP 协议分层模型</h3>
<p>基于TCP/IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。</p>
<p><img src="https://img-1256541035.cos.ap-shanghai.myqcloud.com/imgs/TcpIp-tcpip.webp" alt=""></p>
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/nodejs" class="link blue hover-black">
            Tag: nodejs
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2019/07/20/expressmiddleware/" class="link black dim">
        Express路由与中间件原理（中间件篇）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <code>Express</code> 路由原理见 <a href="http://www.goyth.com/2019/07/20/expressRouter/">Express路由与中间件原理（路由篇）</a> <code>Express</code> 中间件通常用来一些公用的逻辑，并可以将处理的结果挂载在 <code>req</code>、<code>res</code> 上，以供后面的中间件函数，或路由函数使用。因此通常情况下中间件函数会放在路由的前面。在 <code>Express</code> 中，注册一个中间件与注册一个路由一样，也是放在 <code>app.routes</code> 中，只是中间件的 <code>method</code> 为 middle。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2019/07/20/expressrouter/" class="link black dim">
        Express路由与中间件原理（路由篇）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      导入 <code>express</code> 后会得到一个 <code>express</code> 函数，执行这个函数后返回一个 <code>app</code> <code>函数，app</code> 上有一个 <code>listen</code> 函数，执行这个 <code>listen</code> 函数就会启一个 <code>http</code> 服务，通过 <code>app.get</code>、<code>app.post</code>、<code>app.all</code>等函数来注册监听函数，如果 <code>http server</code> 监听到有请求到来，就会调用在 <code>app</code> 上注册的相应的回调函数。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2019/01/12/webpackloader/" class="link black dim">
        Webpack 工作原理（三）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      webpack Loader 是一个符合 <code>commonjs</code> 规范的模块，这个模块导出一个函数，它的主要作用是对源码进行转换，webpack 在调用 Loader时，会将源代码作为参数传递给这个Loader，然后该loader会对源码进行转换，并且返回转换后的内容。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/12/10/webpackflow/" class="link black dim">
        Webpack 工作原理（二）——打包构建流程分析
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      webpack 主要工作流程 Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： <strong>初始化参数</strong>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数； - <strong>开始编译</strong>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的run方法开始执行编译； 确定入口：根据配置中的 entry 找出所有的入口文件 - <strong>编译模块</strong>：从入口文件出发，调用所有配置的 Loader 对模块进行编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/11/17/webpackconfig/" class="link black dim">
        Webpack 工作原理（一）——配置篇
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。构建就是把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/promise" class="link blue hover-black">
            Tag: promise
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/08/03/promise/" class="link black dim">
        Promise实现原理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      1.<code>promise</code> 函数的参数（executor）是一个函数，这个函数有两个参数<code>resolve</code>和<code>reject</code>，这两个参数也都是函数，分别在<code>promise</code>成功和失败时调用。 2. 当构建一个<code>promise</code>实例时，会自动调用这个函数（executor） 3. 每个<code>promise</code>对象都有一个<code>onFulfilledCallback</code>队列和一个<code>onRejectedCallback</code>队列，用来分别存储成功和失败时调用的回调函数
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/regexp" class="link blue hover-black">
            Tag: regexp
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/04/01/jsregexp/" class="link black dim">
        JavaScript 正则表达式
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      正则表达式 一种几乎可以在所有的程序设计语言里和所有的计算机平台上使用的文字处理工具。它可以用来查找特定的信息（搜索），也可以用来查找并编辑特定的信息（替换）。 核心是 匹配，匹配位置或者匹配字符
先简单的介绍一下语法 基本元字符   .： 匹配除了换行符之外的任何单个字符
  \ ： 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前\的'b'通常匹配小写'b'，无论它们出现在哪里。如果加了'\',这个字符变成了一个特殊意义的字符，反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a*/ 代表会匹配 0 a。相反，模式 /a\*/ 将 ' * ' 的特殊性移除，从而可以匹配像 &quot;a*&quot; 这样的字符串。
  | ： 逻辑或操作符
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/router" class="link blue hover-black">
            Tag: router
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2019/05/25/sparouter/" class="link black dim">
        单页面（SPA）路由实现原理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      什么是单页面应用 ? 单页面应用（SPA）即single page application，目前在前后端分离的项目中，一般都是采用 SPA 的模式，整个应用只有一个 html 页面。后端接口只负责提供数据，而页面路由则需要前端自己完成。单页面应用的优势：1. 减少 http 请求数，降低服务器压力；2. 有利于前后端分离；3. 页面流畅度更高，用户体验更加友好。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/sort" class="link blue hover-black">
            Tag: sort
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/02/09/heapsort/" class="link black dim">
        排序算法之堆排序
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      排序算法总览：
堆排序 二叉树 要了解堆首先得了解一下二叉树，在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。
二叉树的每个结点至多只有二棵子树（不存在度大于 2 的结点），二叉树的子树有左右之分，次序不能颠倒。二叉树的第 i 层至多有 2i - 1 个结点；深度为 k 的二叉树至多有 2k - 1 个结点；对任何一棵二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为 n2，则n0 = n2 + 1。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/02/09/mergesort/" class="link black dim">
        排序算法之归并排序
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。
归并排序可以使用递归和迭代两种方式进行实现
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/02/09/quicksort/" class="link black dim">
        排序算法之快速排序
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      快速排序是图灵奖得主 C. R. A. Hoare 于 1960 年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。
分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。
利用分治法可将快速排序的分为三步：</p>
<ol>
<li>在数据集之中，选择一个元素作为”基准”（pivot）。</li>
</ol>
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/02/08/shellsort/" class="link black dim">
        排序算法之希尔排序
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      希尔排序(Shell&rsquo;s Sort)也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： * 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； * 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；
希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/02/08/straightinsertionsort/" class="link black dim">
        排序算法之直接插入排序
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      常见的内部排序算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、基数排序等。这里主要介绍直接插入排序. 直接插入排序(Straight Insertion Sort)的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/02/08/selectionsort/" class="link black dim">
        排序算法之选择排序
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/02/08/bubblesort/" class="link black dim">
        排序算法之冒泡排序
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名“冒泡排序”。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/tcp/ip" class="link blue hover-black">
            Tag: tcp/ip
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/07/04/tcpip/" class="link black dim">
        TCP/IP 协议知识点梳理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h2 id="tcpip协议">TCP/IP协议</h2>
<p>TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。</p>
<h3 id="tcpip-协议分层模型">TCP/IP 协议分层模型</h3>
<p>基于TCP/IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。</p>
<p><img src="https://img-1256541035.cos.ap-shanghai.myqcloud.com/imgs/TcpIp-tcpip.webp" alt=""></p>
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/throttle" class="link blue hover-black">
            Tag: throttle
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/05/10/debounceandthrottle/" class="link black dim">
        JavaScript 之函数防抖与节流
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      函数防抖（debounce) 函数防抖是指在函数调用动作触发n秒后才开始执行，n秒内若再次触发，则重新开始计时，再次等待n秒后才开始执行。如果n秒内不断触发，那就不断重新开始计时，一直等到有一个n秒内没有触发，才开始执行此函数。
根据描述，我们可以用setTimeout来实现一个简单版的防抖函数
第一版 ／** * @ fn 回调函数 * @ delay 延迟时间 *／ function debounce(fn, delay){ let timer = null; return function(){ clearTimeout(timer); timer = setTimeout(fn, delay); } } 由于setTimeout的回调函数内的this是指向window，如果不传参数则argument对象为空，所以我们得修复this的指向，并将argument对象也传给回调函数
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/webpack" class="link blue hover-black">
            Tag: webpack
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2019/01/12/webpackloader/" class="link black dim">
        Webpack 工作原理（三）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      webpack Loader 是一个符合 <code>commonjs</code> 规范的模块，这个模块导出一个函数，它的主要作用是对源码进行转换，webpack 在调用 Loader时，会将源代码作为参数传递给这个Loader，然后该loader会对源码进行转换，并且返回转换后的内容。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/12/10/webpackflow/" class="link black dim">
        Webpack 工作原理（二）——打包构建流程分析
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      webpack 主要工作流程 Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： <strong>初始化参数</strong>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数； - <strong>开始编译</strong>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的run方法开始执行编译； 确定入口：根据配置中的 entry 找出所有的入口文件 - <strong>编译模块</strong>：从入口文件出发，调用所有配置的 Loader 对模块进行编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/11/17/webpackconfig/" class="link black dim">
        Webpack 工作原理（一）——配置篇
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。构建就是把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/websocket" class="link blue hover-black">
            Tag: websocket
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://goyth.cn/2018/07/09/websocket/" class="link black dim">
        WebSocket知识点梳理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h2 id="什么是websocket">什么是WebSocket</h2>
<p>WebSocket是一种在单个TCP连接上进行全双工通讯的协议。它与HTTP协一样，同属于应用层协议。</p>
<h2 id="websocket解决了什么问题">WebSocket解决了什么问题</h2>
<p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，<strong>允许服务端主动向客户端推送数据</strong>。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建<strong>持久性的连接</strong>，并进行<strong>双向数据传输</strong>。
简单说就是解决了浏览器和服务器之间双向数据传输的问题。</p>
    </div>
  </div>
</div>

        
      
    </section>
  </div>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://goyth.cn/" >
    &copy;  GOYTH 2020 
  </a>
    <div>




<a href="https://twitter.com/goythz" target="_blank" class="link-transition twitter link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel="noopener" aria-label="follow on Twitter——Opens in a new window">
  <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>





<a href="https://github.com/jsyt" target="_blank" class="link-transition github link dib z-999 pt3 pt0-l mr1" title="Github link" rel="noopener" aria-label="follow on Github——Opens in a new window">
  <svg  height="32px"  style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
  <path d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"/>
</svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>






</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
