<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RegExp on luke's blog</title><link>https://goyth.cn/tags/regexp/</link><description>Recent content in RegExp on luke's blog</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2019, Weru and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Sun, 01 Apr 2018 21:53:54 +0800</lastBuildDate><atom:link href="https://goyth.cn/tags/regexp/index.xml" rel="self" type="application/rss+xml"/><item><title>JavaScript 正则表达式</title><link>https://goyth.cn/post/jsregexp/</link><pubDate>Sun, 01 Apr 2018 21:53:54 +0800</pubDate><guid>https://goyth.cn/post/jsregexp/</guid><description>正则表达式 一种几乎可以在所有的程序设计语言里和所有的计算机平台上使用的文字处理工具。它可以用来查找特定的信息（搜索），也可以用来查找并编辑特定的信息（替换）。 核心是 匹配，匹配位置或者匹配字符
先简单的介绍一下语法 基本元字符 .： 匹配除了换行符之外的任何单个字符
\ ： 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前\的'b'通常匹配小写'b'，无论它们出现在哪里。如果加了'\',这个字符变成了一个特殊意义的字符，反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a*/ 代表会匹配 0 a。相反，模式 /a\*/ 将 ' * ' 的特殊性移除，从而可以匹配像 &amp;quot;a*&amp;quot; 这样的字符串。
| ： 逻辑或操作符
[ ] ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 . ，\这些字符都表示其本身
[^ ] ：对上面一个集合取非
- ：定义一个区间，例如[A-Z]，其首尾字符在 ASCII 字符集里面
数量元字符 {m,n} ：匹配前面一个字符至少 m 次至多 n 次重复，还有{m}表示匹配 m 次，{m,}表示至少 m 次 + ： 匹配前面一个表达式一次或者多次，相当于 {1,}，记忆方式追加(+)，起码得有一次 * ： 匹配前面一个表达式零次或者多次，相当于 {0,}，记忆方式乘法(*)，可以一次都没有 ?</description></item></channel></rss>