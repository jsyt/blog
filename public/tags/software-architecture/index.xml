<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software Architecture on Luke&#39;s blog</title>
    <link>https://ytop.net/tags/software-architecture/</link>
    <description>Recent content in Software Architecture on Luke&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2020 Luke. All rights reserved.</copyright>
    <lastBuildDate>Mon, 20 Apr 2020 14:59:35 +0800</lastBuildDate>
    
	<atom:link href="https://ytop.net/tags/software-architecture/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>面向对象编程与SOLID原则(一)</title>
      <link>https://ytop.net/post/object-oriented-programming/</link>
      <pubDate>Mon, 20 Apr 2020 14:59:35 +0800</pubDate>
      
      <guid>https://ytop.net/post/object-oriented-programming/</guid>
      <description>面向对象出现的背景 在面向对象之前，主流的编程思想是面向过程。 面向过程是以“过程”或“事件”为核心，用函数来表示“事件”或“过程” 通过组合不同个函数调用来完成一个功能。 面向过程的语言，它的性能更好，但是随着软件的规模和复杂度的不断增加，这时候它的缺点也十分明显：
 代码复用性低 系统规模庞大，内部耦合严重，开发效率低； 系统耦合严重，牵一发动全身，后续修改和扩展困难； 系统逻辑复杂，容易出问题，出问题后很难排查和修复。  为了解决这些问题，就出现了“模块化”、“面向对象”、“组件”等概念。“模块”、“对象”、“组件”，本质上都是对达到一定规模的软件进行拆分，差别只是在于随着软件的复杂度不断增加，拆分的粒度越来越粗，拆分的层次越来越高。
面向对象是以对象为核心，把要解决的问题分解成多个对象，并在对象上定义属性和行为，对象与对象之间通过方法来交互。 面向对象的代码，结构清晰，程序是模块化和结构化，更加符合人类的思维方式；并且易扩展，代码重用率高，可继承，可覆盖，可以设计出高内聚、低耦合的系统；
面向对象三大特征： 封装(Encapsulation) 所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。
继承(Inheritance) 继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；
多态(Polymorphism) 所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。
最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。
面向对象五大原则(SOLID)： 单一职责原则（Single-Resposibility Principle） 一个类应该只做且只能做一件事情
举例来说，假如我们需要从网络上获取一些 JSON 数据，然后解析它，并把结果保存在本地数据库中。根据我们正在编码的平台，这种工作可以使用为数不多的代码来实现。由于代码量不多，我们可能会想把所有的逻辑全部扔到一个类中。但是，根据单一职责原则，这将会是一个糟糕的做法。我们可以清楚地区分 3 个不同的职责：
 从网络上获取 JSON 数据 解析数据 保存解析的结果到数据库中  基于此，我们应该有 3 个类。 第 1 个类应该只处理网络。我们给它提供一个 URL，然后接收 JSON 数据或者在出现问题时，收到一个错误信息。 第 2 个类应该只解析它接收到的 JSON 数据并以相应的格式返回结果。 第 3 个类应该以相应的格式接收 JSON 数据，并把它保存在本地数据库中。
为什么非要这么麻烦呢？通过这样分离代码，我们能获得什么好处呢？其中一个好处就是可测试性。对于网络请求类，我们可以使用一个测试的 URL 分别在请求成功和发生错误的测试用例下来观察它的正确行为。为了测试 JSON 模块，我们可以提供一个模拟的 JSON 数据，然后查看它生成的正确数据。同样的测试原则也适用于数据库类（提供模拟数据，在模拟的数据库上测试结果）。
有了这些测试，如果我们的程序出了问题，我们可以运行测试并查看问题发生在哪个地方。可能是服务器上的某些部分发生了改变，导致我们接收了有损数据。或者数据是正常的，但是我们在 JSON 解析模块中遗漏了什么，致使我们不能正确地解析数据。又或者可能我们正尝试插入数据的数据库中不存在某个列。通过这些测试，我们不必猜测问题出在哪个地方。看到了问题所在，我们就努力地去解决它。
除了可测试性，我们还拥抱了模块化。如果项目需求变更，服务器返回数据的格式是 XML 或者其他的自定义格式而非 JSON，那么我们所要做的就是编写一个处理数据解析的新模块，然后用这个新的代替 JSON 模块。或者可能因为一些奇葩的理由，上述两者我们都需要，而网络模块再根据一些规则调用正确的模块。</description>
    </item>
    
    <item>
      <title>面向对象编程与 SOLID 原则（二）</title>
      <link>https://ytop.net/post/object-oriented-programming2/</link>
      <pubDate>Mon, 20 Apr 2020 13:12:34 +0800</pubDate>
      
      <guid>https://ytop.net/post/object-oriented-programming2/</guid>
      <description>在文章的 第一部分，我们主要讨论了面向对象与前两个 SOLID 原则，它们分别是单一职责原则和开闭原则。在这一部分，我们将讨论接下来的三个原则。
面向对象五大原则(SOLID)： 里氏替换原则（Liskov-Substituion Principle） 子类可以替换父类并且出现在父类能够出现的任何地方
在这个原则中父类应尽可能使用接口或者抽象类来实现。子类通过实现了父类接口，能够替父类的使用地方。通过这个原则，我们客户端在使用父类接口的时候，通过子类实现。
意思就是说我们依赖父类接口，在客户端声明一个父类接口，通过其子类来实现
这个时候就要求子类必须能够替换父类所出现的任何地方，这样做的好处就是，在根据新要求扩展父类接口的新子类的时候而不影响当前客户端的使用！
让我们看一个关于多个自行车的示例。Bike 基类如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Bike { void pedal() { // pedal code } void steer() { // steering code } void handBrakeFront() { // hand braking front code } void handBrakeBack() { // hand braking back code } }   山地自行车类 MountainBike 继承自基类 Bike （山地车有通过齿轮的机械原理调整档位的特性）：</description>
    </item>
    
  </channel>
</rss>