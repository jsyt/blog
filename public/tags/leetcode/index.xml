<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode on Luke&#39;s blog</title>
    <link>https://www.goyth.cn/tags/leetcode/</link>
    <description>Recent content in LeetCode on Luke&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2020 Luke. All rights reserved.</copyright>
    <lastBuildDate>Fri, 13 Mar 2020 15:07:48 +0800</lastBuildDate>
    
	<atom:link href="https://www.goyth.cn/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LeetCode 115. 不同的子序列</title>
      <link>https://www.goyth.cn/post/leetcode115-distinct-subsequences/</link>
      <pubDate>Fri, 13 Mar 2020 15:07:48 +0800</pubDate>
      
      <guid>https://www.goyth.cn/post/leetcode115-distinct-subsequences/</guid>
      <description>115. 不同的子序列 (Distinct Subsequences) Difficulty: 困难
给定一个字符串 S和一个字符串 T，计算在 S 的子序列中 T 出现的个数。
一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，&amp;quot;ACE&amp;quot; 是 &amp;quot;ABCDE&amp;quot; 的一个子序列，而 &amp;quot;AEC&amp;quot; 不是）
示例 1:
1 2 3 4 5 6 7 8 9 10 11 12 13  输入: S = &amp;#34;rabbbit&amp;#34;, T = &amp;#34;rabbit&amp;#34; 输出: 3 解释: 如下图所示, 有 3 种可以从 S 中得到 &amp;#34;rabbit&amp;#34; 的方案。 (上箭头符号 ^ 表示选取的字母) rabbbit ^^^^ ^^ rabbbit ^^ ^^^^ rabbbit ^^^ ^^^   示例 2:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  输入: S = &amp;#34;babgbag&amp;#34;, T = &amp;#34;bag&amp;#34; 输出: 5 解释: 如下图所示, 有 5 种可以从 S 中得到 &amp;#34;bag&amp;#34; 的方案。 (上箭头符号 ^ 表示选取的字母) babgbag ^^ ^ babgbag ^^ ^ babgbag ^ ^^ babgbag ^ ^^ babgbag ^^^   Solution Language: JavaScript</description>
    </item>
    
    <item>
      <title>LeetCode 44. 通配符匹配</title>
      <link>https://www.goyth.cn/post/leetcode44/</link>
      <pubDate>Thu, 12 Mar 2020 00:21:03 +0800</pubDate>
      
      <guid>https://www.goyth.cn/post/leetcode44/</guid>
      <description>44. 通配符匹配 Difficulty: 困难
给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 &#39;?&#39; 和 &#39;*&#39; 的通配符匹配。
1 2  &amp;#39;?&amp;#39; 可以匹配任何单个字符。 &amp;#39;*&amp;#39; 可以匹配任意字符串（包括空字符串）。   两个字符串完全匹配才算匹配成功。
说明:
 s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。  示例 1:
1 2 3 4 5  输入: s = &amp;#34;aa&amp;#34; p = &amp;#34;a&amp;#34; 输出: false 解释: &amp;#34;a&amp;#34; 无法匹配 &amp;#34;aa&amp;#34; 整个字符串。   示例 2:
1 2 3 4 5  输入: s = &amp;#34;aa&amp;#34; p = &amp;#34;*&amp;#34; 输出: true 解释: &amp;#39;*&amp;#39; 可以匹配任意字符串。   示例 3:</description>
    </item>
    
    <item>
      <title>LeetCode 32. 最长有效括号</title>
      <link>https://www.goyth.cn/post/leetcode32/</link>
      <pubDate>Mon, 09 Mar 2020 22:51:54 +0800</pubDate>
      
      <guid>https://www.goyth.cn/post/leetcode32/</guid>
      <description>32. 最长有效括号 Difficulty: 困难
给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。
示例 1:
1 2 3  输入: &amp;#34;(()&amp;#34; 输出: 2 解释: 最长有效括号子串为 &amp;#34;()&amp;#34;   示例 2:
1 2 3  输入: &amp;#34;)()())&amp;#34; 输出: 4 解释: 最长有效括号子串为 &amp;#34;()()&amp;#34;   Solution Language: JavaScript
解法一——暴力求解（超时） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  ​/** * @param {string} s * @return {number} */ var longestValidParentheses = function(s) { let maxLen = 0; function valid (i, j) { let stack = []; while (i &amp;lt; j) { if (s[i++] === &amp;#39;(&amp;#39;) { stack.</description>
    </item>
    
    <item>
      <title>LeetCode 76. 最小覆盖子串</title>
      <link>https://www.goyth.cn/post/leetcode76/</link>
      <pubDate>Mon, 09 Mar 2020 09:53:57 +0800</pubDate>
      
      <guid>https://www.goyth.cn/post/leetcode76/</guid>
      <description>76. 最小覆盖子串 Difficulty: 困难
给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。
示例：
1 2  输入: S = &amp;#34;ADOBECODEBANC&amp;#34;, T = &amp;#34;ABC&amp;#34; 输出: &amp;#34;BANC&amp;#34;   说明：
 如果 S 中不存这样的子串，则返回空字符串 &amp;quot;&amp;quot;。 如果 S 中存在这样的子串，我们保证它是唯一的答案。  解题思路  要送S字符串中找出包含 T 所有字母的最小子串，那么首先就得记录T中有哪些字符，然后再去遍历 S，从S中寻找包含 T 所有字母的子串 这里我们可以先用一个map，needs来记录T中的字符，以及字符的数量 然后维护一个窗口，用索引l和r来表示这个窗口的左右边界，刚开始窗口的大小为0，即l = 0、r = 0 然后开始遍历S，从窗口的右侧依次放入元素，也用一个map， windows来记录S中的字符及其字符的数量 如果windows[c1] === needs[c1]，则说明窗口中有一个字符的数量与T中相等，则将计数器count++ 如果count等于needs中的key的数量和，则说明窗口中有T中所有的字符串，此时窗口所包含的子串就是一个包含 T 所有字母的子串 由于答案是要寻找最小的字串，所以可以记录下符合要求的子串的起始位置以及其长度，起始位置就是l，长度为r - l 找到符合要求的子串后，就开始从窗口的左侧移除字符，直到该子串不符合要求，根据将要移除的字符c，判断windows[c] === needs[c]，如果相等则要将则将计数器count--，然后移除该字符windows[c]--，最后将左边界索引l++ 重复上面的逻辑找出所有可能的子串，比较每一个子串的长度，最后返回最小的子串  Solution Language: JavaScript
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  ​/** * @param {string} s * @param {string} t * @return {string} */ var minWindow = function(s, t) { let windows = {}, needs = {}, l = 0, r = 0, count = 0, start = -1, minLen = Infinity; [.</description>
    </item>
    
    <item>
      <title>LeetCode 727. 最小窗口子序列</title>
      <link>https://www.goyth.cn/post/leetcode727/</link>
      <pubDate>Sun, 08 Mar 2020 17:33:54 +0800</pubDate>
      
      <guid>https://www.goyth.cn/post/leetcode727/</guid>
      <description>727. 最小窗口子序列 Difficulty: 困难
给定字符串 S and T，找出 S 中最短的（连续）子串 W ，使得 T 是 W 的 子序列 。
如果 S 中没有窗口可以包含 T 中的所有字符，返回空字符串 &amp;quot;&amp;quot;。如果有不止一个最短长度的窗口，返回开始位置最靠左的那个。
示例 1：
1 2 3 4 5 6  输入： S = &amp;#34;abcdebdde&amp;#34;, T = &amp;#34;bde&amp;#34; 输出：&amp;#34;bcde&amp;#34; 解释： &amp;#34;bcde&amp;#34; 是答案，因为它在相同长度的字符串 &amp;#34;bdde&amp;#34; 出现之前。 &amp;#34;deb&amp;#34; 不是一个更短的答案，因为在窗口中必须按顺序出现 T 中的元素。   注：
 所有输入的字符串都只包含小写字母。All the strings in the input will only contain lowercase letters. S 长度的范围为 [1, 20000]。 T 长度的范围为 [1, 100]。  解题思路  同时遍历 S 和 T，如果 S[i] === T[j]，那么就 ++i 和 ++j，否则就只 ++i 如果 j === T.</description>
    </item>
    
    <item>
      <title>LeetCode 632. 最小区间</title>
      <link>https://www.goyth.cn/post/leetcode632/</link>
      <pubDate>Sat, 07 Mar 2020 10:21:01 +0800</pubDate>
      
      <guid>https://www.goyth.cn/post/leetcode632/</guid>
      <description>632. 最小区间 Difficulty: 困难
你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。
我们定义如果 b-a &amp;lt; d-c 或者在 b-a == d-c 时 a &amp;lt; c，则区间 [a,b] 比 [c,d] 小。
示例 1:
1 2 3 4 5 6  输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] 输出: [20,24] 解释: 列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。 列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。 列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。   注意:
 给定的列表可能包含重复元素，所以在这里升序表示 &amp;gt;= 。 1 &amp;lt;= k &amp;lt;= 3500 -105&amp;lt;= 元素的值 &amp;lt;= 105 对于使用Java的用户，请注意传入类型已修改为List&amp;lt;List&amp;gt;。重置代码模板后可以看到这项改动。  Solution Language: JavaScript</description>
    </item>
    
    <item>
      <title>LeetCode 340. 至多包含 K 个不同字符的最长子串</title>
      <link>https://www.goyth.cn/post/leetcode340/</link>
      <pubDate>Fri, 06 Mar 2020 02:18:30 +0800</pubDate>
      
      <guid>https://www.goyth.cn/post/leetcode340/</guid>
      <description>340. 至多包含 K 个不同字符的最长子串 Difficulty: 困难
给定一个字符串** _s_** ，找出 **至多 **包含 _k_ 个不同字符的最长子串 **_T_**。
示例 1:
1 2 3  输入: s = &amp;#34;eceba&amp;#34;, k = 2 输出: 3 解释: 则 T 为 &amp;#34;ece&amp;#34;，所以长度为 3。   示例 2:
1 2 3  输入: s = &amp;#34;aa&amp;#34;, k = 1 输出: 2 解释: 则 T 为 &amp;#34;aa&amp;#34;，所以长度为 2。   Solution 解题思路  采用双指针法，用两个指针(l, r)分别记录窗口的左右边界 用 map 来存储字符状态，以字符为 key，字符出现的次数为 value 开始遍历字符串 s，并将字符存入 map 中，如果 map 的键值个数等于 k，则说明找到了一个符合要求的子串，子串的左右边界就是 l 和 r 然后将左边界的值移出窗口，并将左边界 l++，再移动右边界 r++，直到找到下一个符合要求的子串 记录子串的长度，找出所有符合要求的最长子串，并返回该长度  代码 Language: JavaScript</description>
    </item>
    
    <item>
      <title>LeetCode 994. 腐烂的橘子</title>
      <link>https://www.goyth.cn/post/leetcode994/</link>
      <pubDate>Thu, 05 Mar 2020 00:56:39 +0800</pubDate>
      
      <guid>https://www.goyth.cn/post/leetcode994/</guid>
      <description>994. 腐烂的橘子 Difficulty: 简单
在给定的网格中，每个单元格可以有以下三个值之一：
 值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。  每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。
返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。
示例 1：

1 2  输入：[[2,1,1],[1,1,0],[0,1,1]] 输出：4   示例 2：
1 2 3  输入：[[2,1,1],[0,1,1],[1,0,1]] 输出：-1 解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。   示例 3：
1 2 3  输入：[[0,2]] 输出：0 解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。   提示：
 1 &amp;lt;= grid.length &amp;lt;= 10 1 &amp;lt;= grid[0].</description>
    </item>
    
    <item>
      <title>LeetCode 30. 串联所有单词的子串</title>
      <link>https://www.goyth.cn/post/leetcode30/</link>
      <pubDate>Wed, 26 Feb 2020 21:53:54 +0800</pubDate>
      
      <guid>https://www.goyth.cn/post/leetcode30/</guid>
      <description>给定一个字符串 &lt;strong&gt;s&lt;/strong&gt; 和一些长度相同的单词 &lt;strong&gt;words&lt;/strong&gt;找出 &lt;strong&gt;s&lt;/strong&gt; 中恰好可以由 &lt;strong&gt;words&lt;/strong&gt; 中所有单词串联形成的子串的起始位置。
注意子串要与 &lt;strong&gt;words&lt;/strong&gt; 中的单词完全匹配，中间不能有其他字符，但不需要考虑 &lt;strong&gt;words&lt;/strong&gt;中单词串联的顺序。</description>
    </item>
    
  </channel>
</rss>