<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Luke&#39;s blog</title>
    <link>https://ytop.net/</link>
    <description>Recent content on Luke&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2020 Luke. All rights reserved.</copyright>
    <lastBuildDate>Wed, 09 Apr 2014 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ytop.net/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode365 Water and Jug Problem</title>
      <link>https://ytop.net/post/leetcode365-water-and-jug-problem/</link>
      <pubDate>Sun, 22 Mar 2020 17:30:43 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode365-water-and-jug-problem/</guid>
      <description>365. 水壶问题 Difficulty: 中等
有两个容量分别为 x 升 和 y 升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z 升 的水？
如果可以，最后请用以上水壶中的一或两个来盛放取得的 z 升水。
你允许：
 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空  示例 1: (From the famous )
1 2  输入: x = 3, y = 5, z = 4 输出: True   示例 2:
1 2  输入: x = 2, y = 6, z = 5 输出: False   Solution Language: JavaScript
一、DFS解法 解题思路：</description>
    </item>
    
    <item>
      <title>LeetCode 115. 不同的子序列</title>
      <link>https://ytop.net/post/leetcode115-distinct-subsequences/</link>
      <pubDate>Fri, 13 Mar 2020 15:07:48 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode115-distinct-subsequences/</guid>
      <description>115. 不同的子序列 (Distinct Subsequences) Difficulty: 困难
给定一个字符串 S和一个字符串 T，计算在 S 的子序列中 T 出现的个数。
一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，&amp;quot;ACE&amp;quot; 是 &amp;quot;ABCDE&amp;quot; 的一个子序列，而 &amp;quot;AEC&amp;quot; 不是）
示例 1:
1 2 3 4 5 6 7 8 9 10 11 12 13  输入: S = &amp;#34;rabbbit&amp;#34;, T = &amp;#34;rabbit&amp;#34; 输出: 3 解释: 如下图所示, 有 3 种可以从 S 中得到 &amp;#34;rabbit&amp;#34; 的方案。 (上箭头符号 ^ 表示选取的字母) rabbbit ^^^^ ^^ rabbbit ^^ ^^^^ rabbbit ^^^ ^^^   示例 2:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  输入: S = &amp;#34;babgbag&amp;#34;, T = &amp;#34;bag&amp;#34; 输出: 5 解释: 如下图所示, 有 5 种可以从 S 中得到 &amp;#34;bag&amp;#34; 的方案。 (上箭头符号 ^ 表示选取的字母) babgbag ^^ ^ babgbag ^^ ^ babgbag ^ ^^ babgbag ^ ^^ babgbag ^^^   Solution Language: JavaScript</description>
    </item>
    
    <item>
      <title>LeetCode 44. 通配符匹配</title>
      <link>https://ytop.net/post/leetcode44/</link>
      <pubDate>Thu, 12 Mar 2020 00:21:03 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode44/</guid>
      <description>44. 通配符匹配 Difficulty: 困难
给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 &#39;?&#39; 和 &#39;*&#39; 的通配符匹配。
1 2  &amp;#39;?&amp;#39; 可以匹配任何单个字符。 &amp;#39;*&amp;#39; 可以匹配任意字符串（包括空字符串）。   两个字符串完全匹配才算匹配成功。
说明:
 s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。  示例 1:
1 2 3 4 5  输入: s = &amp;#34;aa&amp;#34; p = &amp;#34;a&amp;#34; 输出: false 解释: &amp;#34;a&amp;#34; 无法匹配 &amp;#34;aa&amp;#34; 整个字符串。   示例 2:
1 2 3 4 5  输入: s = &amp;#34;aa&amp;#34; p = &amp;#34;*&amp;#34; 输出: true 解释: &amp;#39;*&amp;#39; 可以匹配任意字符串。   示例 3:</description>
    </item>
    
    <item>
      <title>LeetCode 32. 最长有效括号</title>
      <link>https://ytop.net/post/leetcode32/</link>
      <pubDate>Mon, 09 Mar 2020 22:51:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode32/</guid>
      <description>32. 最长有效括号 Difficulty: 困难
给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。
示例 1:
1 2 3  输入: &amp;#34;(()&amp;#34; 输出: 2 解释: 最长有效括号子串为 &amp;#34;()&amp;#34;   示例 2:
1 2 3  输入: &amp;#34;)()())&amp;#34; 输出: 4 解释: 最长有效括号子串为 &amp;#34;()()&amp;#34;   Solution Language: JavaScript
解法一——暴力求解（超时） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  ​/** * @param {string} s * @return {number} */ var longestValidParentheses = function(s) { let maxLen = 0; function valid (i, j) { let stack = []; while (i &amp;lt; j) { if (s[i++] === &amp;#39;(&amp;#39;) { stack.</description>
    </item>
    
    <item>
      <title>LeetCode 76. 最小覆盖子串</title>
      <link>https://ytop.net/post/leetcode76/</link>
      <pubDate>Mon, 09 Mar 2020 09:53:57 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode76/</guid>
      <description>76. 最小覆盖子串 Difficulty: 困难
给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。
示例：
1 2  输入: S = &amp;#34;ADOBECODEBANC&amp;#34;, T = &amp;#34;ABC&amp;#34; 输出: &amp;#34;BANC&amp;#34;   说明：
 如果 S 中不存这样的子串，则返回空字符串 &amp;quot;&amp;quot;。 如果 S 中存在这样的子串，我们保证它是唯一的答案。  解题思路  要送S字符串中找出包含 T 所有字母的最小子串，那么首先就得记录T中有哪些字符，然后再去遍历 S，从S中寻找包含 T 所有字母的子串 这里我们可以先用一个map，needs来记录T中的字符，以及字符的数量 然后维护一个窗口，用索引l和r来表示这个窗口的左右边界，刚开始窗口的大小为0，即l = 0、r = 0 然后开始遍历S，从窗口的右侧依次放入元素，也用一个map， windows来记录S中的字符及其字符的数量 如果windows[c1] === needs[c1]，则说明窗口中有一个字符的数量与T中相等，则将计数器count++ 如果count等于needs中的key的数量和，则说明窗口中有T中所有的字符串，此时窗口所包含的子串就是一个包含 T 所有字母的子串 由于答案是要寻找最小的字串，所以可以记录下符合要求的子串的起始位置以及其长度，起始位置就是l，长度为r - l 找到符合要求的子串后，就开始从窗口的左侧移除字符，直到该子串不符合要求，根据将要移除的字符c，判断windows[c] === needs[c]，如果相等则要将则将计数器count--，然后移除该字符windows[c]--，最后将左边界索引l++ 重复上面的逻辑找出所有可能的子串，比较每一个子串的长度，最后返回最小的子串  Solution Language: JavaScript
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  ​/** * @param {string} s * @param {string} t * @return {string} */ var minWindow = function(s, t) { let windows = {}, needs = {}, l = 0, r = 0, count = 0, start = -1, minLen = Infinity; [.</description>
    </item>
    
    <item>
      <title>LeetCode 727. 最小窗口子序列</title>
      <link>https://ytop.net/post/leetcode727/</link>
      <pubDate>Sun, 08 Mar 2020 17:33:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode727/</guid>
      <description>727. 最小窗口子序列 Difficulty: 困难
给定字符串 S and T，找出 S 中最短的（连续）子串 W ，使得 T 是 W 的 子序列 。
如果 S 中没有窗口可以包含 T 中的所有字符，返回空字符串 &amp;quot;&amp;quot;。如果有不止一个最短长度的窗口，返回开始位置最靠左的那个。
示例 1：
1 2 3 4 5 6  输入： S = &amp;#34;abcdebdde&amp;#34;, T = &amp;#34;bde&amp;#34; 输出：&amp;#34;bcde&amp;#34; 解释： &amp;#34;bcde&amp;#34; 是答案，因为它在相同长度的字符串 &amp;#34;bdde&amp;#34; 出现之前。 &amp;#34;deb&amp;#34; 不是一个更短的答案，因为在窗口中必须按顺序出现 T 中的元素。   注：
 所有输入的字符串都只包含小写字母。All the strings in the input will only contain lowercase letters. S 长度的范围为 [1, 20000]。 T 长度的范围为 [1, 100]。  解题思路  同时遍历 S 和 T，如果 S[i] === T[j]，那么就 ++i 和 ++j，否则就只 ++i 如果 j === T.</description>
    </item>
    
    <item>
      <title>LeetCode 632. 最小区间</title>
      <link>https://ytop.net/post/leetcode632/</link>
      <pubDate>Sat, 07 Mar 2020 10:21:01 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode632/</guid>
      <description>632. 最小区间 Difficulty: 困难
你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。
我们定义如果 b-a &amp;lt; d-c 或者在 b-a == d-c 时 a &amp;lt; c，则区间 [a,b] 比 [c,d] 小。
示例 1:
1 2 3 4 5 6  输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] 输出: [20,24] 解释: 列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。 列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。 列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。   注意:
 给定的列表可能包含重复元素，所以在这里升序表示 &amp;gt;= 。 1 &amp;lt;= k &amp;lt;= 3500 -105&amp;lt;= 元素的值 &amp;lt;= 105 对于使用Java的用户，请注意传入类型已修改为List&amp;lt;List&amp;gt;。重置代码模板后可以看到这项改动。  Solution Language: JavaScript</description>
    </item>
    
    <item>
      <title>LeetCode 340. 至多包含 K 个不同字符的最长子串</title>
      <link>https://ytop.net/post/leetcode340/</link>
      <pubDate>Fri, 06 Mar 2020 02:18:30 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode340/</guid>
      <description>340. 至多包含 K 个不同字符的最长子串 Difficulty: 困难
给定一个字符串** _s_** ，找出 **至多 **包含 _k_ 个不同字符的最长子串 **_T_**。
示例 1:
1 2 3  输入: s = &amp;#34;eceba&amp;#34;, k = 2 输出: 3 解释: 则 T 为 &amp;#34;ece&amp;#34;，所以长度为 3。   示例 2:
1 2 3  输入: s = &amp;#34;aa&amp;#34;, k = 1 输出: 2 解释: 则 T 为 &amp;#34;aa&amp;#34;，所以长度为 2。   Solution 解题思路  采用双指针法，用两个指针(l, r)分别记录窗口的左右边界 用 map 来存储字符状态，以字符为 key，字符出现的次数为 value 开始遍历字符串 s，并将字符存入 map 中，如果 map 的键值个数等于 k，则说明找到了一个符合要求的子串，子串的左右边界就是 l 和 r 然后将左边界的值移出窗口，并将左边界 l++，再移动右边界 r++，直到找到下一个符合要求的子串 记录子串的长度，找出所有符合要求的最长子串，并返回该长度  代码 Language: JavaScript</description>
    </item>
    
    <item>
      <title>LeetCode 994. 腐烂的橘子</title>
      <link>https://ytop.net/post/leetcode994/</link>
      <pubDate>Thu, 05 Mar 2020 00:56:39 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode994/</guid>
      <description>994. 腐烂的橘子 Difficulty: 简单
在给定的网格中，每个单元格可以有以下三个值之一：
 值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。  每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。
返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。
示例 1：

1 2  输入：[[2,1,1],[1,1,0],[0,1,1]] 输出：4   示例 2：
1 2 3  输入：[[2,1,1],[0,1,1],[1,0,1]] 输出：-1 解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。   示例 3：
1 2 3  输入：[[0,2]] 输出：0 解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。   提示：
 1 &amp;lt;= grid.length &amp;lt;= 10 1 &amp;lt;= grid[0].</description>
    </item>
    
    <item>
      <title>LeetCode 30. 串联所有单词的子串</title>
      <link>https://ytop.net/post/leetcode30/</link>
      <pubDate>Wed, 26 Feb 2020 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode30/</guid>
      <description>给定一个字符串 &lt;strong&gt;s&lt;/strong&gt; 和一些长度相同的单词 &lt;strong&gt;words&lt;/strong&gt;找出 &lt;strong&gt;s&lt;/strong&gt; 中恰好可以由 &lt;strong&gt;words&lt;/strong&gt; 中所有单词串联形成的子串的起始位置。
注意子串要与 &lt;strong&gt;words&lt;/strong&gt; 中的单词完全匹配，中间不能有其他字符，但不需要考虑 &lt;strong&gt;words&lt;/strong&gt;中单词串联的顺序。</description>
    </item>
    
    <item>
      <title>LeetCode 695. 岛屿的最大面积</title>
      <link>https://ytop.net/post/leetcode695-max-area-of-island/</link>
      <pubDate>Tue, 18 Feb 2020 22:36:16 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode695-max-area-of-island/</guid>
      <description>695. 岛屿的最大面积(Max Area of Island) Difficulty: 中等
给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。
找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)
示例 1:
1 2 3 4 5 6 7 8  [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]   对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。
示例 2:
1  [[0,0,0,0,0,0,0,0]]   对于上面这个给定的矩阵, 返回 0。
注意: 给定的矩阵grid 的长度和宽度都不超过 50。
Solution 解题思路：
 要找出最大岛屿的面积，那肯定需要遍历所有的岛屿，这里可以选深度优先或者广度优先来进行遍历 当遍历到当前坐标为 1 时，我们同时需要对当前左边上下左右四个方向进行判断，判断其是否为是岛屿 为了防止岛屿间的重复遍历，每当遍历到当前坐标为 1 后，就将其置为 0  代码 Language: JavaScript</description>
    </item>
    
    <item>
      <title>LeetCode 208. 实现 Trie (前缀树)</title>
      <link>https://ytop.net/post/leetcode208-implement-trie/</link>
      <pubDate>Sat, 15 Feb 2020 12:51:39 +0800</pubDate>
      
      <guid>https://ytop.net/post/leetcode208-implement-trie/</guid>
      <description>208. 实现 Trie (前缀树) Difficulty: 中等
实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。
示例:
1 2 3 4 5 6 7 8  Trie trie = new Trie(); trie.insert(&amp;#34;apple&amp;#34;); trie.search(&amp;#34;apple&amp;#34;); // 返回 true trie.search(&amp;#34;app&amp;#34;); // 返回 false trie.startsWith(&amp;#34;app&amp;#34;); // 返回 true trie.insert(&amp;#34;app&amp;#34;); trie.search(&amp;#34;app&amp;#34;); // 返回 true   说明:
 你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。  Trie 基本结构  字典树，即 Trie 树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串(但不仅限于 字符串)，所以经常被搜索引擎系统用于文本词频统计。 它的优点是:最大限度地减少 无谓的字符串比较，查询效率 比哈希表高。  Trie 基本性质  结点本身不存完整单词; 从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的 字符串; 每个结点的所有子结点路径代表的字符都不相同。  Trie 核心思想  Trie 树的核心思想是空间换时间。 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。  Solution Language: JavaScript</description>
    </item>
    
    <item>
      <title>Express路由与中间件原理（中间件篇）</title>
      <link>https://ytop.net/post/expressmiddleware/</link>
      <pubDate>Sat, 20 Jul 2019 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/expressmiddleware/</guid>
      <description>&lt;code&gt;Express&lt;/code&gt; 路由原理见 &lt;a href=&#34;http://www.goyth.com/2019/07/20/expressRouter/&#34;&gt;Express路由与中间件原理（路由篇）&lt;/a&gt; &lt;code&gt;Express&lt;/code&gt; 中间件通常用来一些公用的逻辑，并可以将处理的结果挂载在 &lt;code&gt;req&lt;/code&gt;、&lt;code&gt;res&lt;/code&gt; 上，以供后面的中间件函数，或路由函数使用。因此通常情况下中间件函数会放在路由的前面。在 &lt;code&gt;Express&lt;/code&gt; 中，注册一个中间件与注册一个路由一样，也是放在 &lt;code&gt;app.routes&lt;/code&gt; 中，只是中间件的 &lt;code&gt;method&lt;/code&gt; 为 middle。</description>
    </item>
    
    <item>
      <title>Express路由与中间件原理（路由篇）</title>
      <link>https://ytop.net/post/expressrouter/</link>
      <pubDate>Sat, 20 Jul 2019 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/expressrouter/</guid>
      <description>导入 &lt;code&gt;express&lt;/code&gt; 后会得到一个 &lt;code&gt;express&lt;/code&gt; 函数，执行这个函数后返回一个 &lt;code&gt;app&lt;/code&gt; &lt;code&gt;函数，app&lt;/code&gt; 上有一个 &lt;code&gt;listen&lt;/code&gt; 函数，执行这个 &lt;code&gt;listen&lt;/code&gt; 函数就会启一个 &lt;code&gt;http&lt;/code&gt; 服务，通过 &lt;code&gt;app.get&lt;/code&gt;、&lt;code&gt;app.post&lt;/code&gt;、&lt;code&gt;app.all&lt;/code&gt;等函数来注册监听函数，如果 &lt;code&gt;http server&lt;/code&gt; 监听到有请求到来，就会调用在 &lt;code&gt;app&lt;/code&gt; 上注册的相应的回调函数。</description>
    </item>
    
    <item>
      <title>golang 学习笔记（一）——语法篇</title>
      <link>https://ytop.net/post/golanglearning01/</link>
      <pubDate>Sat, 08 Jun 2019 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/golanglearning01/</guid>
      <description>golang 应⽤程序⼊⼝  必须是 main 包：package main 必须是 main ⽅法：func main() ⽂件名不⼀定是 main.go  退出返回值 与其他主要编程语⾔的差异
 Go 中 main 函数不⽀持任何返回值 通过 os.Exit 来返回状态  获取命令⾏参数 与其他主要编程语⾔的差异
 main 函数不⽀持传⼊参数 func main(arg []string) 在程序中直接通过 os.Args 获取命令⾏参数  变量量赋值 与其他主要编程语⾔言的差异
 赋值可以进⾏行行⾃自动类型推断 在⼀一个赋值语句句中可以对多个变量量进⾏行行同时赋值  常量量定义 与其他主要编程语⾔言的差异
 快速设置连续值  1 2 3 4 5 6 7 8 9 10 11 12 13 14  const ( Monday = iota + 1	//Monday = 0 + 1  Tuesday	//Tuesday = iota + 1 = 1 + 1  Wednesday	//Wednesday = iota + 1 = 2 + 1  Thursday	//Thursday = iota + 1 = 3 + 1  Friday	//Friday = iota + 1 = 4 + 1  Saturday	//Saturday = iota + 1 = 5 + 1  Sunday	//Sunday = iota + 1 = 6 + 1 ) const ( Open = 1 &amp;lt;&amp;lt; iota Close Pending )   iota是golang语言的常量计数器,只能在常量的表达式中使用。 iota在const关键字出现时将被重置为0(const内部的第一行之前)，const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</description>
    </item>
    
    <item>
      <title>单页面（SPA）路由实现原理</title>
      <link>https://ytop.net/post/sparouter/</link>
      <pubDate>Sat, 25 May 2019 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/sparouter/</guid>
      <description>什么是单页面应用 ? 单页面应用（SPA）即single page application，目前在前后端分离的项目中，一般都是采用 SPA 的模式，整个应用只有一个 html 页面。后端接口只负责提供数据，而页面路由则需要前端自己完成。单页面应用的优势：1. 减少 http 请求数，降低服务器压力；2. 有利于前后端分离；3. 页面流畅度更高，用户体验更加友好。</description>
    </item>
    
    <item>
      <title>Creating a New Theme</title>
      <link>https://ytop.net/post/creating-a-new-theme/</link>
      <pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ytop.net/post/creating-a-new-theme/</guid>
      <description>Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description>
    </item>
    
    <item>
      <title>(Hu)go Template Primer</title>
      <link>https://ytop.net/post/goisforlovers/</link>
      <pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ytop.net/post/goisforlovers/</guid>
      <description>Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.
This document is a brief primer on using Go templates.</description>
    </item>
    
    <item>
      <title>Webpack 工作原理（三）</title>
      <link>https://ytop.net/post/webpackloader/</link>
      <pubDate>Sat, 12 Jan 2019 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/webpackloader/</guid>
      <description>webpack Loader 是一个符合 &lt;code&gt;commonjs&lt;/code&gt; 规范的模块，这个模块导出一个函数，它的主要作用是对源码进行转换，webpack 在调用 Loader时，会将源代码作为参数传递给这个Loader，然后该loader会对源码进行转换，并且返回转换后的内容。</description>
    </item>
    
    <item>
      <title>编写一个 Babel 插件</title>
      <link>https://ytop.net/post/babelplugin/</link>
      <pubDate>Sun, 06 Jan 2019 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/babelplugin/</guid>
      <description>Babel转译流程 Babel 对源码进行转译时，主要有三个步骤  首先通过Babylon 将源码转化成 AST 然后再通过babel-traverse遍历 AST，找到需要更改的 AST 节点，对其进行修改 根据修改后的 AST，通过babel-generator将修改后的 AST重新生成源码 Babel插件主要是处理第二步。  Babylon Babylon 是 Babel 的解析器，主要负责将源码转化成 AST。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import * as babylon from &amp;#34;babylon&amp;#34;; const code = `function square(n) { return n * n; }`; babylon.parse(code); // Node { // type: &amp;#34;File&amp;#34;, // start: 0, // end: 38, // loc: SourceLocation {.</description>
    </item>
    
    <item>
      <title>Babel 核心模块介绍</title>
      <link>https://ytop.net/post/babel/</link>
      <pubDate>Sat, 05 Jan 2019 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/babel/</guid>
      <description>Babel 介绍 Babel 是一个通用的多用途 JavaScript 编译器。通过 Babel 你可以使用（并创建）下一代的 JavaScript，以及下一代的 JavaScript 工具。 Babel 把用最新标准编写的 JavaScript 代码向下编译成可以在今天随处可用的版本。 这一过程叫做“源码到源码”编译， 也被称为转换编译（transpiling，是一个自造合成词，即转换＋编译。以下也简称为转译）。
例如，Babel 能够将新的 ES2015 箭头函数语法：
1  const square = n =&amp;gt; n * n;   转译为：
1 2 3  const square = function square(n) { return n * n; };   Babel核心模块介绍 Babel-core 可以看做 babel 的编译器。babel 的核心 api 都在这里面。它可以把 js 代码，抽象成 AST，然后修改 AST ，再根据AST生成新的js代码，这就是Babel 转译的过程。但是如何转译、转译哪些内容，着需要我们事先设置好的 plugin，plugin 就是如何转译的规则。
babel-register 它在底层改写了node的require方法，引入babel-register之后所有require并以.es6, .es, .</description>
    </item>
    
    <item>
      <title>抽象语法树AST介绍</title>
      <link>https://ytop.net/post/ast/</link>
      <pubDate>Sun, 23 Dec 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/ast/</guid>
      <description>js编译执行的第一步是读取 js 文件中的字符流，然后通过词法分析生成token，之后再通过语法分析生成 AST（Abstract Syntax Tree），最后生成机器码执行。词法分析，也称之为扫描（scanner），简单来说就是调用 next() 方法，一个一个字母的来读取字符，然后与定义好的 JavaScript 关键字符做比较，生成对应的Token。Token 是一个不可分割的最小单元，例如 var 这三个字符，它只能作为一个整体，语义上不能再被分解，因此它是一个 Token。</description>
    </item>
    
    <item>
      <title>Webpack 工作原理（二）——打包构建流程分析</title>
      <link>https://ytop.net/post/webpackflow/</link>
      <pubDate>Mon, 10 Dec 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/webpackflow/</guid>
      <description>webpack 主要工作流程 Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： &lt;strong&gt;初始化参数&lt;/strong&gt;：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数； - &lt;strong&gt;开始编译&lt;/strong&gt;：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的run方法开始执行编译； 确定入口：根据配置中的 entry 找出所有的入口文件 - &lt;strong&gt;编译模块&lt;/strong&gt;：从入口文件出发，调用所有配置的 Loader 对模块进行编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</description>
    </item>
    
    <item>
      <title>JavaScript垃圾回收机制与内存泄漏</title>
      <link>https://ytop.net/post/v8gc/</link>
      <pubDate>Sun, 02 Dec 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/v8gc/</guid>
      <description>程序的运行需要分配内存，内存资源是有限的，当程序运行结束后，就应该回收其内存资源。JavaScript使用自动内存管理，也称为垃圾回收机制（garbage collector）。自动垃圾回收的优点是可以简化开发，不用时刻惦记着回收不再使用的变量，降低内存泄漏的可能性；缺点是无法完全的掌握内存的分配以及回收的具体过程。</description>
    </item>
    
    <item>
      <title>Webpack 工作原理（一）——配置篇</title>
      <link>https://ytop.net/post/webpackconfig/</link>
      <pubDate>Sat, 17 Nov 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/webpackconfig/</guid>
      <description>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。构建就是把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。</description>
    </item>
    
    <item>
      <title>MongoDB 知识点梳理(二)</title>
      <link>https://ytop.net/post/mongodb2/</link>
      <pubDate>Sat, 13 Oct 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/mongodb2/</guid>
      <description>MongoDB通过配置项启动数据库 启动服务器 1  mongod --config mongo.conf   启动客户端 1  mongo --port 50000      参数 含义     &amp;ndash;dbpath 指定数据库文件的目录   &amp;ndash;port 端口 默认是27017 28017   &amp;ndash;fork 以后台守护的方式进行启动   &amp;ndash;logpath 指定日志文件输出路径   &amp;ndash;config 指定一个配置文件   &amp;ndash;auth 以安全方式启动数据库，默认不验证    mongo.conf 1 2 3  dbpath=/Users/demon/coding/mongo/data logpath=/Users/demon/coding/mongo/log port=50000   导入导出数据 这命令是保存成了文件格式
 mongoimport 导出数据 mongoexport 导入数据     参数 含义      -h [ &amp;ndash;host ]	连接的数据库    &amp;ndash;port 端口号    -u 用户名    -p 密码    -d 导出的数据库    -d 导出的数据库    -c 指定导出的集合    -o 导出的文件存储路径    -q 进行过滤     准备数据</description>
    </item>
    
    <item>
      <title>MongoDB 知识点梳理（一）</title>
      <link>https://ytop.net/post/mongodb/</link>
      <pubDate>Fri, 12 Oct 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/mongodb/</guid>
      <description>MongoDB是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。 MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB 将数据存储为一个文档，数据结构由键值(key=&amp;gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</description>
    </item>
    
    <item>
      <title>Emoji Support</title>
      <link>https://ytop.net/post/emoji-support/</link>
      <pubDate>Sun, 05 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ytop.net/post/emoji-support/</guid>
      <description>&lt;p&gt;Emoji can be enabled in a Hugo project in a number of ways.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Promise实现原理</title>
      <link>https://ytop.net/post/promise/</link>
      <pubDate>Fri, 03 Aug 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/promise/</guid>
      <description>1.&lt;code&gt;promise&lt;/code&gt; 函数的参数（executor）是一个函数，这个函数有两个参数&lt;code&gt;resolve&lt;/code&gt;和&lt;code&gt;reject&lt;/code&gt;，这两个参数也都是函数，分别在&lt;code&gt;promise&lt;/code&gt;成功和失败时调用。 2. 当构建一个&lt;code&gt;promise&lt;/code&gt;实例时，会自动调用这个函数（executor） 3. 每个&lt;code&gt;promise&lt;/code&gt;对象都有一个&lt;code&gt;onFulfilledCallback&lt;/code&gt;队列和一个&lt;code&gt;onRejectedCallback&lt;/code&gt;队列，用来分别存储成功和失败时调用的回调函数</description>
    </item>
    
    <item>
      <title>HTTP知识点整理</title>
      <link>https://ytop.net/post/http2/</link>
      <pubDate>Wed, 11 Jul 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/http2/</guid>
      <description>HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。于2015年正式发布，HTTP/2解决了HTTP1.1线头阻塞、重复建立TCP连接等问题，充分利用TCP连接的高效传输，使得网络延迟大幅下降，网络传输速度大幅提升。
HTTP/0.9 - 1991 第一版的HTTP文档是1991年提出来的 HTTP/0.9。这是有史以来最简单的协议；它仅有一个GET方法。如果客户端要访问服务器上的一些网页，它会作出如下的简单请求：
1  GET /index.html   并且来自服务器的响应内容如下：
1 2  (response body) (connection closed)   也就是说，服务器会得到这个请求，然后通过HTML格式回复响应内容，且一旦响应内容发送完毕，就会关闭这个连接。归纳一下：
 没有header数据块 GET方法是唯一允许的方法 必须以HTML格式响应  HTTP/1.0 - 1996 1996年，HTTP/1.0 诞生了，它在原版本上做出了极大的改善。不像 HTTP/0.9 仅能以HTML格式响应，HTTP/1.1 现在可以处理其他的响应格式了，例如：图像，视频文件，纯文本或其他任何的内容类型。它增加了更多的方法（即 POST 和 HEAD），请求/响应的格式也发生了改变，请求和响应中均加入了HTTP头信息，响应数据还增加了状态码标识，还介绍了字符集的支持、多部分发送、权限、缓存、内容编码等很多内容。
如下所示，这是一个通过 HTTP/1.0 请求和响应的例子：
1 2 3 4  GET / HTTP/1.0 Host: kamranahmed.info User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) Accept: */*   正如你所见，客户端除了发送请求以外，它还发送了它的个人信息，要求响应类型等。而在 HTTP/0.9 中因为没有头信息，客户端是不会发送这些信息的。
上面的例子对应的服务器响应结果如下：
1 2 3 4 5 6 7 8 9  HTTP/1.</description>
    </item>
    
    <item>
      <title>WebSocket知识点梳理</title>
      <link>https://ytop.net/post/websocket/</link>
      <pubDate>Mon, 09 Jul 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/websocket/</guid>
      <description>什么是WebSocket WebSocket是一种在单个TCP连接上进行全双工通讯的协议。它与HTTP协一样，同属于应用层协议。
WebSocket解决了什么问题 WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 简单说就是解决了浏览器和服务器之间双向数据传输的问题。
HTTP协议可以实现双向数据传输吗 答案肯定是可以的，在HTTP协议中我们通常使用轮询来实现双向通信。 轮询是通过在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。
HTTP1.1长连接与WebSocket长连接有什么区别 HTTP1.1默认启用&amp;quot;Connection: Keep-Alive&amp;rdquo;，使得在发送完http请求和应答后，不会立刻将连接关闭，在后续的http请求和应答可以继续使用这个连接，避免创建新的TCP连接时三次握手及断开连接时四次挥手的额外消耗。这个keep-alive一般会有固定的时间限制。如Apache是5s，而nginx默认是75s，超过这个时间服务器就会主动把TCP连接关闭了，因为不关闭的话会有大量的TCP连接占用系统资源。所以这个keep-alive并不是为了长连接设计的，只是为了提高http请求的效率。而WebSocket长连接的关闭可以由通过调用相应的API，主动控制。 HTTP1.1长连接是无状态的，每一个请求对应一个应答，并且每个请求和应答里面都包含了完整的头部信息；而WebSocket长连接是有状态的，在建立连接后，WebSocket只用携带少量头部字段信息（如数据包长度、掩码），不用携带状态信息。
WebSocket的优点  较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。 更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。 保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。 更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。 可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。 更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。  WebSocket兼容性情况 WebSocket握手协议 WebSocket 是独立的、创建在 TCP 上的协议。
Websocket 通过 HTTP/1.1 协议的101状态码进行握手。
为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”（handshaking）。
例子 一个典型的Websocket握手请求如下：
客户端请求
1 2 3 4 5 6 7  GET / HTTP/1.1 Upgrade: websocket Connection: Upgrade Host: example.com Origin: http://example.com Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ== Sec-WebSocket-Version: 13   服务器回应
1 2 3 4 5  HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s= Sec-WebSocket-Location: ws://example.</description>
    </item>
    
    <item>
      <title>DNS知识点梳理</title>
      <link>https://ytop.net/post/dns/</link>
      <pubDate>Sat, 07 Jul 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/dns/</guid>
      <description>DNS 服务器 DNS( Domain Name System)是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于TCP/IP网络，它所提供的服务是用来将主机名和域名转换为IP地址的工作。DNS就是这样的一位“翻译官”，它的基本工作原理可用下图来表示。
全世界所有的人每天上网都会使用DNS服务器，如果大家都去同一个地方访问某一台服务器，时延将会非常大，所以DNS服务器的架构必须是分布式、高并发、高可用，如下图：
 根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址 顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址 权威 DNS 服务器 ：返回相应主机的 IP 地址  DNS域名解析过程 当用户在浏览器中输入www.abc.com并按下回车键后：
第一步查找本地DNS缓存 本地DNS缓存有浏览器DNS缓存，操作系统（OS）DNS缓存，路由器DNS缓存，按照浏览器、操作系统、路由器的顺序依次查找www.abc.com对应的DNS缓存，如果缓存命中则停止。
1、浏览器DNS缓存 浏览器在获取网站域名的实际IP地址后会对其IP进行缓存，减少网络请求的损耗。 当浏览器收到一个DNS解析请求后，首先会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制，通常情况下为几分钟到几小时不等。这个缓存时间太长和太短都不好，如果缓存时间太长，一旦域名被解析到的IP有变化，会导致被客户端缓存的域名无法解析到变化后的IP地址，以致该域名不能正常解析，这段时间内有可能会有一部分用户无法访问网站。如果时间设置太短，会导致用户每次访问网站都要重新解析一次域名。 浏览器DNS缓存的时间跟DNS服务器返回的TTL值无关。 通常每种浏览器都有一个固定的DNS缓存时间，其中Chrome的过期时间是1分钟，在这个期限内不会重新请求DNS。Chrome浏览器看本身的DNS缓存时间比较方便，在地址栏输入
1  chrome://net-internals/#dns   2、系统（OS）DNS缓存 如果用户浏览器缓存中没有数据，浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果。其实操作系统也有一个域名解析的过程，在Windows中可以通过C:\Windows\System32\drivers\etc\hosts文件来设置，在Linux中可以通过/etc/hosts文件来设置，用户可以将任何域名解析到任何能够访问的IP地址。例如，我们在测试时可以将一个域名解析到一台测试服务器上，这样不用修改任何代码就能测试到单独服务器上的代码的业务逻辑是否正确。正是因为有这种本地DNS解析的规程，所以有黑客就可能通过修改用户的域名来把特定的域名解析到他指定的IP地址上，导致这些域名被劫持。
第二步查找ISP DNS缓存 如果本地DNS缓存没有对应的记录，就要用到我们网络配置中的&amp;quot;DNS服务器地址&amp;quot;了。操作系统会把这个域名发送给这个ISP，也就是本地区的域名服务器。这个DNS通常都提供给用户本地互联网接入的一个DNS解析服务，例如用户是在学校接入互联网，那么用户的DNS服务器肯定在学校；如果用户是在小区接入互联网，那么用户的DNS就是再提供接入互联网的应用提供商，即电信或联通，也就是通常说的SPA，那么这个DNS通常也会在用户所在城市的某个角落，不会很远。Windows环境下通过命令行输入ipconfig，Linux环境下通过cat /etc/resolv.conf就可以查询配置的DNS服务器了。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受到域名的失效时间控制的。大约80%的域名解析到这里就结束了，所以ISP主要承担了域名的解析工作。
递归搜索 在前面都没有办法命中的DNS缓存的情况下,(1)本地 DNS服务器即将该请求转发到互联网上的根DNS（即一个完整域名最后面的那个点，通常省略不写）。(2)根DNS将所要查询域名中的顶级域（假设要查询www.abc.com，该域名的顶级域就是.com）的服务器IP地址返回到本地DNS。(3) 本地DNS根据返回的IP地址，再向顶级域（就是.com域）发送请求。(4) .com域服务器再将域名中的权威域名服务器（abc.com）的IP地址返回给本地DNS。(5) 本地DNS再向权威域名服务器（abc.com）发送请求进行查询。(6) 权威DNS查询到对应的IP后，就将IP返回给本地DNS服务器，本地 DNS 再将 IP 地址返回客户端。
DNS有关的网络性能优化 1、减少DNS查找，避免重定向，浏览器DNS缓存 、计算机DNS缓存、 服务器DNS缓存、使用Keep-Alive特性 来减少DNS查找。考虑影响DNS缓存的因素：
 服务器可以设置TTL值表示DNS记录的存活时间。本机DNS缓存将根据这个TTL值判断DNS记录什么时候被抛弃，这个TTL值一般都不会设置很大，主要是考虑到快速故障转移的问题。 浏览器DNS缓存也有自己的过期时间，这个时间是独立于本机DNS缓存的，相对也比较短，例如chrome只有1分钟左右。 浏览器DNS记录的数量也有限制，如果短时间内访问了大量不同域名的网站，则较早的DNS记录将被抛弃，必须重新查找。不过即使浏览器丢弃了DNS记录，操作系统的DNS缓存也有很大机率保留着该记录，这样可以避免通过网络查询而带来的延迟。  2、DNS的预解析 DNS 请求需要的带宽非常小，但是延迟却有点高，这点在手机网络上特别明显。预读取 DNS 能让延迟明显减少一些，例如用户点击链接时。在某些情况下，延迟能减少一秒钟。</description>
    </item>
    
    <item>
      <title>TCP/IP 协议知识点梳理</title>
      <link>https://ytop.net/post/tcpip/</link>
      <pubDate>Wed, 04 Jul 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/tcpip/</guid>
      <description>TCP/IP协议 TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。
TCP/IP 协议分层模型 基于TCP/IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。
 物理层将二进制的0和1和电压高低，光的闪灭和电波的强弱信号进行转换 链路层代表驱动 网络层  使用 IP 协议，IP 协议基于 IP 转发分包数据 IP 协议是个不可靠协议，不会重发 IP 协议发送失败会使用ICMP 协议通知失败 ARP 解析 IP 中的 MAC 地址，MAC 地址由网卡出厂提供 IP 还隐含链路层的功能，不管双方底层的链路层是啥，都能通信   传输层  通用的 TCP 和 UDP 协议  TCP 协议面向有连接，能正确处理丢包，传输顺序错乱的问题，但是为了建立与断开连接，需要至少7次的发包收包，资源浪费 UDP 面向无连接，不管对方有没有收到，如果要得到通知，需要通过应用层     会话层以上分层  TCP/IP 分层中，会话层，表示层，应用层集中在一起 网络管理通过 SNMP 协议    TCP/IP 协议模型封包解包 TCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。
上图清楚地表示了TCP/IP协议中每个层的作用，而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。
TCP三次握手 TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。
第一次握手： 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手： 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手： 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</description>
    </item>
    
    <item>
      <title>浏览器的缓存机制梳理</title>
      <link>https://ytop.net/post/browsecache/</link>
      <pubDate>Sun, 01 Jul 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/browsecache/</guid>
      <description>概述 浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种：
HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)，如下图
HTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体，如下图
注：通用信息头指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；实体头则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。这里只是为了方便理解，将通用信息头，响应头/请求头，实体头都归为了HTTP头。
以上的概念在这里我们不做多讲解，只简单介绍，有兴趣的童鞋可以自行研究。
缓存过程分析 浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：
由上图我们可以知道：
  浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
  浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中
  以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。
强制缓存 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：
 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：   存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图   存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图  那么强制缓存的缓存规则是什么？
当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。
Expires Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。
Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？
到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么Cache-Control又是如何控制的呢？
Cache-Control 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：
  public：所有内容都将被缓存（客户端和代理服务器都可缓存）
  private：所有内容只有客户端可以缓存，Cache-Control的默认取值
  no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
  no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
  max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效
  接下来，我们直接看一个例子，如下：
由上面的例子我们可以知道：
  HTTP响应报文中expires的时间值，是一个绝对值</description>
    </item>
    
    <item>
      <title>浏览器常见跨域方式梳理</title>
      <link>https://ytop.net/post/crossdomain/</link>
      <pubDate>Fri, 29 Jun 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/crossdomain/</guid>
      <description>跨域是由于浏览器同源策略导致的，所以跨域只存在于浏览器端，非浏览器端不存在跨域问题，浏览器对跨域的请求、应答都能正常发送接收，只是浏览器在接收跨域应答时，将应答拦截了，所以我们需要一些额外的处理或设置让浏览器将跨域的应答返回给我们。
常见的跨域处理方式有：  jsonp CORS iframe + postMessage iframe + window.name iframe + location.hash iframe + domain nginx代理 Nodejs中间件 WebSocket  jsonp 跨域 jsonp 跨域是利用script标签天生具备跨域的特性，script的src属性发起的请求不受浏览器同源策略的限制，所以我们可以动态生成一个script标签对象，将要请求数据的url赋值给script标签的src属性，然后将此script标签append到body中。但是服务端怎么返回数据呢，返回的数据又如何处理呢？此时我们还需要预先写好一个解析数据的函数analyzeData，并将这个函数名通过请求的url一并传给后端，后端收到后，直接请求的数据放在解析函数analyzeData的参数中analyzeData({a:1,b:2,c:3})并返回，当次script标签加载完毕后就会直接执行analyzeData({a:1,b:2,c:3})方法。
1 2 3 4 5 6 7 8  // 预先写好一个解析数据的函数 function analyzeData(data) { console.log(data) } var sct = document.createElement(&amp;#39;script&amp;#39;) sct.src = &amp;#39;http://goyth.com/json?callback=analyzeData&amp;#39; document.body.appendChild(sct)   jsop 的优点是兼容性好，能兼容低版本的浏览器，缺点是只支持get请求，不支持其他方式的请求，并且对回调函数的错误处理不太友好。
CORS(跨域资源共享) CORS 全称为跨域资源共享（Cross-origin resource sharing），它是 W3C 用来允许XMLHttpRequest请求跨域的一个标准，也是现在主流的跨域方案。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。IE8+：IE8/9需要使用XDomainRequest对象来支持CORS。
整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。
因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。
跨域请求只需要在服务端应答报文头增加一个Access-Control-Allow-Origin字段，该字段是的值要么是请求时Origin字段的值，要么是一个 * ，Access-Control-Allow-Origin=Origin字段的值 表示只接受该域的请求，Access-Control-Allow-Origin=* 表示接受任意域名的请求。此时的请求是不带Cookie的，如果需要带上Cookie，则需要在发起请求时将 XMLHttpRequest 实例的 withCredentials 属性设置为 true，在服务端将Access-Control-Allow-Credentials字段设置为true。</description>
    </item>
    
    <item>
      <title>JavaScript之apply、call和bind的模拟实现</title>
      <link>https://ytop.net/post/applyandcall/</link>
      <pubDate>Sun, 27 May 2018 22:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/applyandcall/</guid>
      <description>apply() apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。当第一个参数为 null 时，函数上下文为 window。
1 2 3 4 5 6 7 8 9  var obj = { name : &amp;#39;luke&amp;#39; } function func(age, gender){ console.log(this.name + &amp;#39; &amp;#39; + age + &amp;#39; &amp;#39; + gender); } func.apply(obj, [18, &amp;#39;male&amp;#39;]); // luke 18 male   apply模拟实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  Function.</description>
    </item>
    
    <item>
      <title>N-Sum 问题</title>
      <link>https://ytop.net/post/nsum/</link>
      <pubDate>Fri, 25 May 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/nsum/</guid>
      <description>问题描述 给定一个包含多个整数且排好序的数组 nums 和一个目标值 target，判断 nums 中是否存在 N(N&amp;gt;1) 个元素，使得 N 个元素之和与 target 相等？找出所有满足条件且不重复的N元组。
解题思路 通过递归降幂将 N-Sum问题 降幂到 2-Sum 问题，然后采用两边加逼的办法求解
JavaScript 版本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  /** * @param {number[]} nums * @param {number} target * @param {number} n * @param {number[]} result * @param {number[]} results 结果集 */ function findNsum(nums, target, n, result, results) { if(n&amp;lt;2 || nums.</description>
    </item>
    
    <item>
      <title>浏览器渲染之回流（Reflow）与重绘（Repaint）</title>
      <link>https://ytop.net/post/reflowandrepaint/</link>
      <pubDate>Fri, 25 May 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/reflowandrepaint/</guid>
      <description>回流（Reflow）和重绘（Repaint）的定义 回流（Reflow） 对于DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式（浏览器的、开发人员定义的等）来计算，并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow。 重绘（Repaint） 当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为 repaint。</description>
    </item>
    
    <item>
      <title>浏览器页面渲染流程梳理</title>
      <link>https://ytop.net/post/browserrendering/</link>
      <pubDate>Wed, 23 May 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/browserrendering/</guid>
      <description>浏览器渲染基本流程 浏览器渲染流程如下图所示：
大概可以划分成以下几个步骤：
 通过HTML解析器解析HTML文本并构建DOM tree 通过CSS解析器解析CSS样式表并构建CSSOM tree 根据DOM tree 和 CSSOM tree 构建 Render tree Render tree 刚构建完后是没有元素节点坐标、尺寸大小等信息的，此时需要通过Layout(Reflow)进行布局处理，计算出元素在屏幕上显示的位置，尺寸大小等信息。 遍历渲染树，对每一个元素节点进行绘制（Painting）  解析（Parsing） 解析的过程分为两个步骤：词法分析和语法分析。 词法分析负责将输入内容分解成一个个有效标记；而语法分析负责根据语言的语法规则分析文档的结构，从而构建解析树。通过词法分析可以将无关的字符（比如空格和换行符）分离出来。
解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。
如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。
转译(Translation) 很多时候，解析树还不是最终产品。解析通常是在转译过程中使用的，而转译是指将输入文档转换成另一种格式。编译就是这样一个例子。编译器可将源代码编译成机器代码，具体过程是首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。
HTML解析 解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。 解析树的根节点是“Document”对象。
DOM 与标记之间几乎是一一对应的关系。比如下面这段标记：
1 2 3 4 5 6 7 8  &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt; Hello World &amp;lt;/p&amp;gt; &amp;lt;div&amp;gt; &amp;lt;img src=&amp;#34;example.png&amp;#34;/&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;   可翻译成如下的 DOM 树：</description>
    </item>
    
    <item>
      <title>JavaScript 之函数防抖与节流</title>
      <link>https://ytop.net/post/debounceandthrottle/</link>
      <pubDate>Thu, 10 May 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/debounceandthrottle/</guid>
      <description>函数防抖（debounce) 函数防抖是指在函数调用动作触发n秒后才开始执行，n秒内若再次触发，则重新开始计时，再次等待n秒后才开始执行。如果n秒内不断触发，那就不断重新开始计时，一直等到有一个n秒内没有触发，才开始执行此函数。
根据描述，我们可以用setTimeout来实现一个简单版的防抖函数
第一版 1 2 3 4 5 6 7 8 9 10 11 12  ／** * @ fn 回调函数 * @ delay 延迟时间 *／ function debounce(fn, delay){ let timer = null; return function(){ clearTimeout(timer); timer = setTimeout(fn, delay); } }   由于setTimeout的回调函数内的this是指向window，如果不传参数则argument对象为空，所以我们得修复this的指向，并将argument对象也传给回调函数
第二版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  ／** * @ fn 回调函数 * @ delay 延迟时间 *／ function debounce(fn, delay){ let timer = null; return function(){ let context = this, arg = arguments; clearTimeout(timer); timer = setTimeout(function(){ fn.</description>
    </item>
    
    <item>
      <title>Migrate to Hugo from Jekyll</title>
      <link>https://ytop.net/post/migrate-from-jekyll/</link>
      <pubDate>Thu, 10 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ytop.net/post/migrate-from-jekyll/</guid>
      <description>Move static content to static Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png  should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png  Additionally, you&amp;rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description>
    </item>
    
    <item>
      <title>JavaScript 原型链与继承</title>
      <link>https://ytop.net/post/prototypeandextend/</link>
      <pubDate>Mon, 23 Apr 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/prototypeandextend/</guid>
      <description>原型对象 无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性指向 prototype 属性所在的函数。
1 2  function Person(){ }   当我们用构造函数创建一个实例时，也会为这个实例创建一个 __proto__ 属性，这个__proto__ 属性是一个指针指向构造函数的原型对象
1 2 3 4  let person = new Person(); person.__proto__ === Person.prototype // true let person1 = new Person(); person1.__proto__ === Person.prototype // true   由于同一个构造函数创建的所有实例对象的__proto__ 属性都指向这个构造函数的原型对象，因此所有的实例对象都会共享构造函数的原型对象上所有的属性和方法，一旦原型对象上的属性或方法发生改变，所有的实例对象都会受到影响。
1 2 3 4 5 6 7 8 9 10 11  function Person(){ } Person.prototype.name = &amp;#34;Luke&amp;#34;; Person.prototype.age = 18; let person1 = new Person(); let person2 = new Person(); alert(person1.</description>
    </item>
    
    <item>
      <title>Getting Started with Hugo</title>
      <link>https://ytop.net/post/hugoisforlovers/</link>
      <pubDate>Mon, 02 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ytop.net/post/hugoisforlovers/</guid>
      <description>Step 1. Install Hugo Go to Hugo releases and download the appropriate version for your OS and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at Install Hugo
Step 2. Build the Docs Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:
 Clone the Hugo repository Go into the repo Run hugo in server mode and build the docs Open your browser to http://localhost:1313  Corresponding pseudo commands:</description>
    </item>
    
    <item>
      <title>JavaScript 正则表达式</title>
      <link>https://ytop.net/post/jsregexp/</link>
      <pubDate>Sun, 01 Apr 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/jsregexp/</guid>
      <description>正则表达式 一种几乎可以在所有的程序设计语言里和所有的计算机平台上使用的文字处理工具。它可以用来查找特定的信息（搜索），也可以用来查找并编辑特定的信息（替换）。 核心是 匹配，匹配位置或者匹配字符
先简单的介绍一下语法 基本元字符   .： 匹配除了换行符之外的任何单个字符
  \ ： 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前\的&#39;b&#39;通常匹配小写&#39;b&#39;，无论它们出现在哪里。如果加了&#39;\&#39;,这个字符变成了一个特殊意义的字符，反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a*/ 代表会匹配 0 a。相反，模式 /a\*/ 将 &#39; * &#39; 的特殊性移除，从而可以匹配像 &amp;quot;a*&amp;quot; 这样的字符串。
  | ： 逻辑或操作符
  [ ] ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 . ，\这些字符都表示其本身
  [^ ] ：对上面一个集合取非
  - ：定义一个区间，例如[A-Z]，其首尾字符在 ASCII 字符集里面
  数量元字符  {m,n} ：匹配前面一个字符至少 m 次至多 n 次重复，还有{m}表示匹配 m 次，{m,}表示至少 m 次 + ： 匹配前面一个表达式一次或者多次，相当于 {1,}，记忆方式追加(+)，起码得有一次 * ： 匹配前面一个表达式零次或者多次，相当于 {0,}，记忆方式乘法(*)，可以一次都没有 ?</description>
    </item>
    
    <item>
      <title>排序算法之堆排序</title>
      <link>https://ytop.net/post/heapsort/</link>
      <pubDate>Fri, 09 Feb 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/heapsort/</guid>
      <description>排序算法总览：
堆排序 二叉树 要了解堆首先得了解一下二叉树，在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。
二叉树的每个结点至多只有二棵子树（不存在度大于 2 的结点），二叉树的子树有左右之分，次序不能颠倒。二叉树的第 i 层至多有 2i - 1 个结点；深度为 k 的二叉树至多有 2k - 1 个结点；对任何一棵二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为 n2，则n0 = n2 + 1。
树和二叉树的三个主要差别：
 树的结点个数至少为 1，而二叉树的结点个数可以为 0 树中结点的最大度数没有限制，而二叉树结点的最大度数为 2 树的结点无左、右之分，而二叉树的结点有左、右之分  二叉树又分为完全二叉树（complete binary tree）和满二叉树（full binary tree）
满二叉树：一棵深度为 k，且有 2k - 1 个节点称之为满二叉树
完全二叉树：深度为 k，有 n 个节点的二叉树，当且仅当其每一个节点都与深度为 k 的满二叉树中序号为 1 至 n 的节点对应时，称之为完全二叉树
什么是堆？ 堆（二叉堆）可以视为一棵完全的二叉树，完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。
如下图，是一个堆和数组的相互关系
对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标：
 Parent(i) = floor(i/2)，i 的父节点下标 Left(i) = 2i，i 的左子节点下标 Right(i) = 2i + 1，i 的右子节点下标  二叉堆一般分为两种：最大堆和最小堆。</description>
    </item>
    
    <item>
      <title>排序算法之归并排序</title>
      <link>https://ytop.net/post/mergesort/</link>
      <pubDate>Fri, 09 Feb 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/mergesort/</guid>
      <description>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。
归并排序可以使用递归和迭代两种方式进行实现</description>
    </item>
    
    <item>
      <title>排序算法之快速排序</title>
      <link>https://ytop.net/post/quicksort/</link>
      <pubDate>Fri, 09 Feb 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/quicksort/</guid>
      <description>快速排序是图灵奖得主 C. R. A. Hoare 于 1960 年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。
分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。
利用分治法可将快速排序的分为三步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在数据集之中，选择一个元素作为”基准”（pivot）。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>排序算法之希尔排序</title>
      <link>https://ytop.net/post/shellsort/</link>
      <pubDate>Thu, 08 Feb 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/shellsort/</guid>
      <description>希尔排序(Shell&amp;rsquo;s Sort)也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： * 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； * 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；
希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序。</description>
    </item>
    
    <item>
      <title>排序算法之直接插入排序</title>
      <link>https://ytop.net/post/straightinsertionsort/</link>
      <pubDate>Thu, 08 Feb 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/straightinsertionsort/</guid>
      <description>常见的内部排序算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、基数排序等。这里主要介绍直接插入排序. 直接插入排序(Straight Insertion Sort)的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。</description>
    </item>
    
    <item>
      <title>排序算法之选择排序</title>
      <link>https://ytop.net/post/selectionsort/</link>
      <pubDate>Thu, 08 Feb 2018 21:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/selectionsort/</guid>
      <description>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。</description>
    </item>
    
    <item>
      <title>排序算法之冒泡排序</title>
      <link>https://ytop.net/post/bubblesort/</link>
      <pubDate>Thu, 08 Feb 2018 10:53:54 +0800</pubDate>
      
      <guid>https://ytop.net/post/bubblesort/</guid>
      <description>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名“冒泡排序”。</description>
    </item>
    
    <item>
      <title>About Hugo</title>
      <link>https://ytop.net/about/</link>
      <pubDate>Wed, 09 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://ytop.net/about/</guid>
      <description>Hugo is the world’s fastest framework for building websites. It is written in Go.
It makes use of a variety of open source projects including:
 https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Learn more and contribute on GitHub.</description>
    </item>
    
  </channel>
</rss>